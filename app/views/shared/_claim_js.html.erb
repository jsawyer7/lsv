<%= javascript_tag do %>
  window.validatedClaim = null;

  function showClaimStep() {
    console.log('Showing claim step');
    document.getElementById('claim-step').style.display = 'block';
    document.getElementById('evidence-step').style.display = 'none';
    const errorMessage = document.querySelector('.error-message');
    if (errorMessage) {
      errorMessage.style.display = 'none';
      errorMessage.textContent = '';
    }
    // Show the AI claim assistant greeting
    startAIChatbotGreeting();
  }

  function showClaimStepAndResetIllustration() {
    console.log('showClaimStepAndResetIllustration called');
    showClaimStep();
    // Show AI Claim Assistant, hide AI Evidence Assistant
    const aiChatbotContainer = document.getElementById('ai-chatbot-container');
    const aiEvidenceContainer = document.getElementById('ai-evidence-chatbot-container');
    
    console.log('AI Chatbot container:', aiChatbotContainer);
    console.log('AI Evidence container:', aiEvidenceContainer);
    
    if (aiChatbotContainer) {
      aiChatbotContainer.style.display = 'flex';
      console.log('AI Chatbot container display set to flex');
    } else {
      console.error('AI Chatbot container not found!');
    }
    
    if (aiEvidenceContainer) {
      aiEvidenceContainer.style.display = 'none';
    }
    
    const sourcesColumns = document.getElementById('sources-columns');
    if (sourcesColumns) sourcesColumns.style.display = 'none';
    const errorMessage = document.querySelector('.error-message');
    if (errorMessage) {
      errorMessage.style.display = 'none';
      errorMessage.textContent = '';
    }
    // Show the AI Claim Assistant greeting only on initial load or when returning to claim step
    startAIChatbotGreeting();
  }

  function showEvidenceStep() {
    console.log('Showing evidence step');
    document.getElementById('claim-step').style.display = 'none';
    document.getElementById('evidence-step').style.display = 'block';
    
    const validatedClaimDisplay = document.getElementById('validated-claim-display');
    if (validatedClaimDisplay && window.validatedClaim) {
      validatedClaimDisplay.value = window.validatedClaim;
    }
    // Only show evidence assistant
    document.getElementById('ai-evidence-chatbot-container').style.display = 'flex';
    document.getElementById('ai-chatbot-container').style.display = 'none';
    // Reset evidence assistant chat
    startAIEvidenceChatbot();

    // Make evidence section editable and show Add Evidence button
    const evidencesContainer = document.getElementById('evidences-container');
    // Evidence units are now handled by _evidence_units_js.html.erb
    // Old evidence system has been removed
    // Hide sources columns
    const sourcesColumns = document.getElementById('sources-columns');
    if (sourcesColumns) sourcesColumns.style.display = 'none';
  }

  // --- AI Evidence Assistant logic ---
  let aiEvidenceChatHistory = [
    { role: "system", content: "You are an expert assistant for evidence suggestion. Help users find a single, clear, and relevant piece of evidence for their claim. Respond conversationally, and always end with: 'Do you want me to add this as evidence? (Yes/No)'" }
  ];

  function appendEvidenceChatMessage(role, text) {
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
    const msg = document.createElement('div');
    msg.className = 'ai-chatbot-message ' + (role === 'user' ? 'user' : 'ai');
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  let lastEvidenceSuggestion = '';

  function startAIEvidenceChatbot() {
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
    messagesDiv.innerHTML = '';
    appendEvidenceChatMessage('ai', 'Hi! I am your AI Evidence Assistant. Ask me anything about the evidence you want to add.');
    lastEvidenceSuggestion = '';
    aiEvidenceChatHistory = [
      { role: "system", content: "You are an expert assistant for evidence suggestion. Help users find a single, clear, and relevant piece of evidence for their claim. Respond conversationally, and always end with: 'Do you want me to add this as evidence? (Yes/No)'" }
    ];
  }

  function streamAIEvidenceResponse(userMsg) {
    appendEvidenceChatMessage('ai', 'Thinking...');
    aiEvidenceChatHistory.push({ role: 'user', content: userMsg });
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
          fetch('/ai/evidence_suggestion', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
        },
        body: JSON.stringify({ messages: aiEvidenceChatHistory })
      })
    .then(async response => {
      if (!response.body) throw new Error('No response body');
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
        }
      }
      // Try to parse the buffered response as JSON
      let evidenceObj = null;
      try {
        // Replace smart quotes with standard quotes
        buffer = buffer.replace(/[""]/g, '"').replace(/['']/g, "'");
        // Try to extract the first {...} block from the buffer
        const match = buffer.match(/{[\s\S]*}/);
        if (match) {
          evidenceObj = JSON.parse(match[0]);
        } else {
          throw new Error('No JSON found');
        }
      } catch (e) {
        appendEvidenceChatMessage('ai', 'Sorry, I could not understand the evidence response.');
        return;
      }
      let formatted = '';
      if (evidenceObj.reference) formatted += evidenceObj.reference + '\n';
      if (evidenceObj.original) formatted += 'Original: ' + evidenceObj.original + '\n';
      if (evidenceObj.translation) formatted += 'Translation: ' + evidenceObj.translation + '\n';
      if (evidenceObj.explanation) formatted += '\n' + evidenceObj.explanation + '\n';
      formatted = formatted.trim() + '\n\nDo you want me to add this as evidence? (Yes/No)';
      // Stream the formatted string character by character into a single chat message
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let i = 0;
      function streamChar() {
        if (i <= formatted.length) {
          aiDiv.innerHTML = formatted.slice(0, i).replace(/\n/g, '<br>');
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
          i++;
          setTimeout(streamChar, 12);
        }
      }
      streamChar();
      lastEvidenceSuggestion = JSON.stringify({
        reference: evidenceObj.reference || '',
        original: evidenceObj.original || '',
        translation: evidenceObj.translation || ''
      });
      aiEvidenceChatHistory.push({ role: 'assistant', content: buffer });
    })
    .catch(err => {
      appendEvidenceChatMessage('ai', 'Sorry, there was a problem getting suggestions.');
    });
  }

  // --- AI Chatbot logic ---
  function appendChatMessage(role, text) {
    console.log('appendChatMessage called with:', role, text);
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    console.log('Messages div in appendChatMessage:', messagesDiv);
    if (messagesDiv) {
      const msg = document.createElement('div');
      msg.className = 'ai-chatbot-message ' + (role === 'user' ? 'user' : 'ai');
      msg.textContent = text;
      messagesDiv.appendChild(msg);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      console.log('Message appended successfully');
    } else {
      console.error('Messages div not found in appendChatMessage!');
    }
  }

  function startAIChatbotGreeting() {
        const userName = document.getElementById('claim-form-wrapper')?.dataset.userName || 'there';
    const messagesDiv = document.getElementById('ai-chatbot-messages');
          messagesDiv.innerHTML = '';
      appendChatMessage('ai', `Hi ${userName}, I am your AI Claim Assistant. You can enter your claim in the claim box, or ask me for help or clarification about how to build a strong claim.`);
        }

  function isHelpRequest(text) {
    return /\b(how|what|help|guide|advice|should|can|could|\?)\b/i.test(text);
  }

  function streamAIClaimGuidance(userMsg) {
        appendChatMessage('ai', 'Let me help you...');
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    fetch('/ai/claim_guidance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ question: userMsg })
    })
    .then(async response => {
      if (!response.body) throw new Error('No response body');
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
          while (buffer.length > 0) {
            aiMsg += buffer[0];
            aiDiv.textContent = aiMsg;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            buffer = buffer.slice(1);
            await new Promise(r => setTimeout(r, 12));
          }
        }
      }
    })
    .catch(err => {
      appendChatMessage('ai', 'Sorry, there was a problem getting guidance.');
    });
  }

  // [EVIDENCE UNITS & AI EVIDENCE ASSISTANT LOGIC START]
  // --- Evidence Units State ---
  let evidenceUnits = [];
  let currentEvidenceUnit = null;
  // Global variables for source management
  let primarySourcesHash = new Set();
  let secondarySourcesHash = new Set();
  let evidenceSourcesHash = new Set();
  let isDragging = false; // Flag to prevent UI updates during drag operations
  let draggedFromList = null; // Track which list the drag started from
  window.evidenceSourcesHash = evidenceSourcesHash; // Make it globally accessible

  // Available sources for validation
  const AVAILABLE_SOURCES = ['Quran', 'Tanakh', 'Catholic', 'Ethiopian', 'Protestant', 'Historical'];

  // Unique hash to maintain state of primary and secondary sources
  // let primarySourcesHash = new Set();
  // let secondarySourcesHash = new Set();

  function setupEvidenceControls() {
    const addEvidenceBtn = document.getElementById('add-evidence-btn');
    const evidenceTypeSelector = document.getElementById('evidence-type-selector');
    const evidenceTypeOptions = document.querySelectorAll('.evidence-type-option');

    // Show/hide evidence type selector
    if (addEvidenceBtn && evidenceTypeSelector) {
      addEvidenceBtn.addEventListener('click', function() {
        if (evidenceTypeSelector.style.display === 'none') {
          evidenceTypeSelector.style.display = 'block';
          addEvidenceBtn.innerHTML = '<i class="fa fa-times"></i> Cancel';
        } else {
          evidenceTypeSelector.style.display = 'none';
          addEvidenceBtn.innerHTML = '<i class="fa fa-plus"></i> Add Evidence';
        }
      });
    }

    // Handle evidence type selection
    evidenceTypeOptions.forEach(option => {
      option.addEventListener('click', function() {
        const evidenceType = this.getAttribute('data-type');
        createEvidenceUnit(evidenceType);
        // Hide selector and reset button
        evidenceTypeSelector.style.display = 'none';
        addEvidenceBtn.innerHTML = '<i class="fa fa-plus"></i> Add Evidence';
      });
    });
  }

  function createEvidenceUnit(initialType) {
    const unitId = Date.now();
    const evidenceUnit = {
      id: unitId,
      sections: {},
      expanded: true
    };
    evidenceUnits.push(evidenceUnit);
    currentEvidenceUnit = evidenceUnit;
    // Create evidence unit element
    const container = document.getElementById('evidences-container');
    const unitElement = document.createElement('div');
    unitElement.className = 'evidence-unit';
    unitElement.id = `evidence-unit-${unitId}`;
    unitElement.innerHTML = `
      <div class="evidence-unit-header" onclick="toggleEvidenceUnit(${unitId})">
        <div class="evidence-unit-title">Evidence ${evidenceUnits.length}</div>
        <div class="evidence-unit-actions">
          <button type="button" class="toggle-evidence-unit-btn" onclick="event.stopPropagation(); toggleEvidenceUnit(${unitId})">
            <i class="fa fa-chevron-down"></i>
          </button>
          <button type="button" class="remove-evidence-unit-btn" onclick="event.stopPropagation(); removeEvidenceUnit(${unitId})">
            <i class="fa fa-times"></i>
          </button>
        </div>
      </div>
      <div class="evidence-unit-content expanded">
        <div class="evidence-sections" id="evidence-sections-${unitId}"></div>
        <div class="evidence-section-options" id="evidence-section-options-${unitId}"></div>
      </div>
    `;
    container.appendChild(unitElement);
    addEvidenceSection(unitId, initialType);
    updateAvailableSectionButtons(unitId);
    showEvidenceChatbot(initialType);
    updateCombinedEvidenceField();
  }

  function addEvidenceSection(unitId, sectionType) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit) return;
    const sectionId = Date.now();
    
    // Initialize section as array if it doesn't exist
    if (!evidenceUnit.sections[sectionType]) {
      evidenceUnit.sections[sectionType] = [];
    }
    
    // Get the current count before adding the new section
    const currentCount = evidenceUnit.sections[sectionType].length;
    
    // Add new section to the array
    evidenceUnit.sections[sectionType].push({
      id: sectionId,
      type: sectionType,
      content: '',
      details: '',
      expanded: true,
      sources: []
    });
    
    // Create the section element
    const sectionsContainer = document.getElementById(`evidence-sections-${unitId}`);
    const sectionElement = document.createElement('div');
    sectionElement.className = 'evidence-section';
    sectionElement.id = `evidence-section-${sectionId}`;
    sectionElement.setAttribute('data-section-type', sectionType);
    sectionElement.setAttribute('data-unit-id', unitId);
    sectionElement.setAttribute('data-section-index', currentCount);
    
    const sectionTitle = getSectionTitle(sectionType, currentCount + 1);
    sectionElement.innerHTML = `
      <div class="evidence-section-header" onclick="toggleEvidenceSection(${sectionId})">
        <div class="evidence-section-title">${sectionTitle}</div>
        <div class="evidence-section-actions">
          <button type="button" class="toggle-section-btn" onclick="event.stopPropagation(); toggleEvidenceSection(${sectionId})">
            <i class="fa fa-chevron-down"></i>
          </button>
          <button type="button" class="remove-section-btn" onclick="event.stopPropagation(); removeEvidenceSection(${unitId}, '${sectionType}', ${currentCount})">
            <i class="fa fa-times"></i>
          </button>
        </div>
      </div>
      <div class="evidence-section-content expanded">
        <div class="evidence-section-placeholder">
          <p>Click "Add ${getSectionDisplayName(sectionType)}" to generate ${getSectionDisplayName(sectionType).toLowerCase()} evidence.</p>
        </div>
      </div>
    `;
    
    sectionsContainer.appendChild(sectionElement);
    updateAvailableSectionButtons(unitId);
    showEvidenceChatbot(sectionType);
    updateCombinedEvidenceField();
  }

  function updateAvailableSectionButtons(unitId) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit) return;
    
    const optionsContainer = document.getElementById(`evidence-section-options-${unitId}`);
    if (!optionsContainer) return;
    
    // Clear existing buttons
    optionsContainer.innerHTML = '';
    
    // Get all available section types
    const allSectionTypes = ['verse', 'historical', 'definition', 'logic'];
    
    // For each section type, show the "Add" button if it's not already added
    // or if it's verse type (allow multiple verses)
    allSectionTypes.forEach(sectionType => {
      const hasSection = evidenceUnit.sections[sectionType] && evidenceUnit.sections[sectionType].length > 0;
      const shouldShowButton = !hasSection || sectionType === 'verse'; // Always show verse button
      
      if (shouldShowButton) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'add-section-btn';
        button.textContent = `+ Add ${getSectionDisplayName(sectionType)}`;
        button.onclick = () => addEvidenceSection(unitId, sectionType);
        optionsContainer.appendChild(button);
      }
    });
  }

  function toggleEvidenceUnit(unitId) {
    const unitElement = document.getElementById(`evidence-unit-${unitId}`);
    const contentElement = unitElement.querySelector('.evidence-unit-content');
    const toggleBtn = unitElement.querySelector('.toggle-evidence-unit-btn');
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (evidenceUnit) {
      evidenceUnit.expanded = !evidenceUnit.expanded;
      if (evidenceUnit.expanded) {
        contentElement.classList.add('expanded');
        toggleBtn.classList.remove('collapsed');
      } else {
        contentElement.classList.remove('expanded');
        toggleBtn.classList.add('collapsed');
      }
    }
  }

  function toggleEvidenceSection(sectionId) {
    const sectionElement = document.getElementById(`evidence-section-${sectionId}`);
    const contentElement = sectionElement.querySelector('.evidence-section-content');
    const toggleBtn = sectionElement.querySelector('.toggle-section-btn');
    if (contentElement.classList.contains('expanded')) {
      contentElement.classList.remove('expanded');
      toggleBtn.classList.add('collapsed');
    } else {
      contentElement.classList.add('expanded');
      toggleBtn.classList.remove('collapsed');
    }
  }

  function removeEvidenceUnit(unitId) {
    evidenceUnits = evidenceUnits.filter(unit => unit.id !== unitId);
    const unitElement = document.getElementById(`evidence-unit-${unitId}`);
    if (unitElement) { unitElement.remove(); }
    updateCombinedEvidenceField();
    updateEvidenceSourcesHash();
  }

  function removeEvidenceSection(unitId, sectionType, index) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit || !evidenceUnit.sections[sectionType] || index < 0 || index >= evidenceUnit.sections[sectionType].length) return;
    evidenceUnit.sections[sectionType].splice(index, 1);
    const sectionElement = document.querySelector(`[data-section-type="${sectionType}"][data-unit-id="${unitId}"]`);
    if (sectionElement) { sectionElement.remove(); }
    updateAvailableSectionButtons(unitId);
    updateCombinedEvidenceField();
    updateEvidenceSourcesHash();
  }

  function updateCombinedEvidenceField() {
    const combinedField = document.getElementById('combined-evidence-field');
    const evidenceData = evidenceUnits.map(unit => ({ id: unit.id, sections: unit.sections }));
    if (combinedField) combinedField.value = JSON.stringify(evidenceData);
  }

  // --- Source Management Functions ---
  function updateEvidenceSourcesHash() {
    evidenceSourcesHash.clear();
    
    evidenceUnits.forEach(unit => {
      Object.values(unit.sections).forEach(sections => {
        if (Array.isArray(sections)) {
          // Handle multiple sections (e.g., multiple verses)
          sections.forEach(section => {
            if (section.sources && Array.isArray(section.sources)) {
              // Handle new sources array format
              section.sources.forEach(source => {
                if (AVAILABLE_SOURCES.includes(source)) {
                  evidenceSourcesHash.add(source);
                }
              });
            } else if (section.source) {
              // Handle old single source format
              const sources = section.source.split(',').map(s => s.trim());
              sources.forEach(source => {
                if (AVAILABLE_SOURCES.includes(source)) {
                  evidenceSourcesHash.add(source);
                }
              });
            }
          });
        } else {
          // Handle single section (backward compatibility)
          const section = sections;
          if (section.sources && Array.isArray(section.sources)) {
            section.sources.forEach(source => {
              if (AVAILABLE_SOURCES.includes(source)) {
                evidenceSourcesHash.add(source);
              }
            });
          } else if (section.source) {
            const sources = section.source.split(',').map(s => s.trim());
            sources.forEach(source => {
              if (AVAILABLE_SOURCES.includes(source)) {
                evidenceSourcesHash.add(source);
              }
            });
          }
        }
      });
    });
    
    console.log('Updated evidence sources hash:', Array.from(evidenceSourcesHash));
  }

  function determinePrimaryAndSecondarySources() {
    const allSources = Array.from(evidenceSourcesHash);
    console.log('All sources from hash:', allSources);
    
    // Check if user has already made drag and drop modifications
    const hasUserModifications = primarySourcesHash.size > 0 || secondarySourcesHash.size > 0;
    
    if (hasUserModifications) {
      console.log('User has already made drag and drop modifications, preserving them');
      console.log('Current primary sources hash:', Array.from(primarySourcesHash));
      console.log('Current secondary sources hash:', Array.from(secondarySourcesHash));
      
      // Return the current state of the hashes (respecting user choices)
      return {
        primary: Array.from(primarySourcesHash),
        secondary: Array.from(secondarySourcesHash)
      };
    }
    
    // Only reset hashes if user hasn't made any modifications
    console.log('No user modifications detected, setting up initial state based on evidence');
    
    // All detected sources from evidence should be primary sources
    const primarySources = allSources;
    
    // Secondary sources are all available sources that are NOT in primary sources
    const secondarySources = AVAILABLE_SOURCES.filter(source => 
      !primarySources.includes(source)
    );
    
    // Update the unique hashes
    primarySourcesHash.clear();
    secondarySourcesHash.clear();
    
    primarySources.forEach(source => primarySourcesHash.add(source));
    secondarySources.forEach(source => secondarySourcesHash.add(source));
    
    console.log('Primary sources (from evidence):', primarySources);
    console.log('Secondary sources (remaining):', secondarySources);
    console.log('Primary sources hash:', Array.from(primarySourcesHash));
    console.log('Secondary sources hash:', Array.from(secondarySourcesHash));
    
    return {
      primary: primarySources,
      secondary: secondarySources
    };
  }

  function createSourceElement(source) {
    const sourceElement = document.createElement('div');
    sourceElement.className = 'source-item';
    sourceElement.setAttribute('draggable', 'true');
    sourceElement.setAttribute('data-source', source);
    sourceElement.innerHTML = `
      <span class="source-name">${source}</span>
    `;
    return sourceElement;
  }

  function addDragListeners(element) {
    element.addEventListener('dragstart', function(e) {
      console.log('Drag start event triggered for:', this.getAttribute('data-source'));
      isDragging = true;
      draggedFromList = this.parentNode.id; // Track which list the drag started from
      e.dataTransfer.setData('text/plain', this.getAttribute('data-source'));
      this.classList.add('dragging');
    });
    
    element.addEventListener('dragend', function(e) {
      console.log('Drag end event triggered for:', this.getAttribute('data-source'));
      isDragging = false;
      draggedFromList = null; // Reset when drag ends
      this.classList.remove('dragging');
      // Remove dragover class from all sources lists
      document.querySelectorAll('.sources-list').forEach(list => {
        list.classList.remove('dragover');
      });
    });
    
    element.addEventListener('dragover', function(e) {
      e.preventDefault();
    });
    
    element.addEventListener('drop', function(e) {
      e.preventDefault();
      // Drop logic is now handled in the list drop event handler
      // Remove dragover class
      document.querySelectorAll('.sources-list').forEach(list => {
        list.classList.remove('dragover');
      });
    });
  }

  // Add drag and drop listeners to sources lists
  function setupSourcesDragAndDrop() {
    const sourcesLists = document.querySelectorAll('.sources-list');
    
    sourcesLists.forEach(list => {
      list.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('dragover');
        console.log('Dragover on list:', this.id);
      });
      
      list.addEventListener('dragleave', function(e) {
        // Only remove class if we're leaving the list entirely
        if (!this.contains(e.relatedTarget)) {
          this.classList.remove('dragover');
        }
      });
      
      list.addEventListener('drop', function(e) {
        console.log('List drop event triggered for list:', this.id);
        e.preventDefault();
        this.classList.remove('dragover');
        
        // Handle the actual drop logic here
        const source = e.dataTransfer.getData('text/plain');
        const sourceElement = document.querySelector(`[data-source="${source}"]`);
        
        console.log('List drop event triggered:', {
          source: source,
          sourceElement: sourceElement,
          targetList: this,
          draggedFromList: draggedFromList,
          oldParent: sourceElement ? sourceElement.parentNode : null
        });
        
        if (sourceElement && draggedFromList && draggedFromList !== this.id) {
          console.log('Moving from', draggedFromList, 'to', this.id);
          
          // Remove from old list hash
          if (draggedFromList === 'primary-sources-list') {
            primarySourcesHash.delete(source);
            console.log('Removed from primary hash:', source);
          } else if (draggedFromList === 'secondary-sources-list') {
            secondarySourcesHash.delete(source);
            console.log('Removed from secondary hash:', source);
          }
          
          // Add to new list hash
          if (this.id === 'primary-sources-list') {
            primarySourcesHash.add(source);
            console.log('Added to primary hash:', source);
          } else if (this.id === 'secondary-sources-list') {
            secondarySourcesHash.add(source);
            console.log('Added to secondary hash:', source);
          }
          
          this.appendChild(sourceElement);
          updateHiddenFields();
          
          // Refresh the UI to ensure consistency
          console.log('Current primary sources hash:', Array.from(primarySourcesHash));
          console.log('Current secondary sources hash:', Array.from(secondarySourcesHash));
          
          // Add a small delay to ensure drag and drop completes
          setTimeout(() => {
            console.log('Drag and drop completed. Final state:');
            console.log('Primary sources:', Array.from(primarySourcesHash));
            console.log('Secondary sources:', Array.from(secondarySourcesHash));
          }, 100);
        } else {
          console.log('No move detected - same list or invalid drag');
        }
      });
    });
  }

  function updateSourcesUI() {
    console.log('updateSourcesUI called');
    console.log('Call stack:', new Error().stack);
    
    // Skip updates if currently dragging to prevent conflicts
    if (isDragging) {
      console.log('Skipping updateSourcesUI because currently dragging');
      return;
    }
    
    // Use the current state of the source hashes (respecting user's drag and drop choices)
    const primarySources = Array.from(primarySourcesHash);
    const secondarySources = Array.from(secondarySourcesHash);
    console.log('Primary sources from hash:', primarySources);
    console.log('Secondary sources from hash:', secondarySources);
    
    const aiChatbotContainer = document.getElementById('ai-chatbot-container');
    const aiEvidenceChatbotContainer = document.getElementById('ai-evidence-chatbot-container');
    const sourcesColumns = document.getElementById('sources-columns');
    
    if (aiChatbotContainer) {
      console.log('Hiding AI chatbot container');
      aiChatbotContainer.style.display = 'none';
    }
    if (aiEvidenceChatbotContainer) {
      console.log('Hiding AI evidence chatbot container');
      aiEvidenceChatbotContainer.style.display = 'none';
    }
    if (sourcesColumns) {
      console.log('Showing sources columns');
      sourcesColumns.style.display = 'flex';
    }
    
    // Update primary sources
    const primarySourcesList = document.getElementById('primary-sources-list');
    if (primarySourcesList) {
      console.log('Updating primary sources list with:', primarySources);
      primarySourcesList.innerHTML = '';
      primarySources.forEach(source => {
        console.log('Creating source element for:', source);
        const sourceElement = createSourceElement(source);
        addDragListeners(sourceElement);
        primarySourcesList.appendChild(sourceElement);
      });
    } else {
      console.error('Primary sources list not found');
    }
    
    // Update secondary sources - show all available sources that are not in primary
    const secondarySourcesList = document.getElementById('secondary-sources-list');
    if (secondarySourcesList) {
      console.log('Updating secondary sources list');
      secondarySourcesList.innerHTML = '';
      
      // Get all available sources that are not in primary
      const availableSecondarySources = AVAILABLE_SOURCES.filter(source => 
        !primarySources.includes(source)
      );
      
      console.log('Available secondary sources:', availableSecondarySources);
      
      availableSecondarySources.forEach(source => {
        console.log('Creating source element for:', source);
        const sourceElement = createSourceElement(source);
        addDragListeners(sourceElement);
        secondarySourcesList.appendChild(sourceElement);
      });
    } else {
      console.error('Secondary sources list not found');
    }
    
    // Setup drag and drop for sources lists
    setupSourcesDragAndDrop();
    
    // Update hidden fields
    updateHiddenFields();
  }

  function updateHiddenFields() {
    const primarySourcesList = document.getElementById('primary-sources-list');
    const secondarySourcesList = document.getElementById('secondary-sources-list');
    const primarySourcesField = document.getElementById('primary-sources-field');
    const secondarySourcesField = document.getElementById('secondary-sources-field');
    
    // Get sources from the hashes for more reliable state management
    const primarySources = Array.from(primarySourcesHash);
    const secondarySources = Array.from(secondarySourcesHash);
    
    if (primarySourcesField) {
      primarySourcesField.value = JSON.stringify(primarySources);
      console.log('Updated primary sources field:', primarySources);
    }
    
    if (secondarySourcesField) {
      secondarySourcesField.value = JSON.stringify(secondarySources);
      console.log('Updated secondary sources field:', secondarySources);
    }
  }

  // --- AI Evidence Assistant Chatbot ---
  function showEvidenceChatbot(type) {
    const chatbotContainer = document.getElementById('ai-evidence-chatbot-container');
    const chatbotHeader = document.getElementById('ai-evidence-chatbot-header');
    const chatbotMessages = document.getElementById('ai-evidence-chatbot-messages');
    const headers = { 'verse': 'AI Verse Assistant', 'historical': 'AI Historical Assistant', 'definition': 'AI Definition Assistant', 'logic': 'AI Logic Assistant' };
    if (chatbotHeader) chatbotHeader.textContent = headers[type] || 'AI Evidence Assistant';
    if (chatbotMessages) chatbotMessages.innerHTML = '';
    if (chatbotContainer) chatbotContainer.style.display = 'flex';
    
    // Hide AI Claim Assistant and sources columns
    const aiChatbot = document.getElementById('ai-chatbot-container');
    const sourcesColumns = document.getElementById('sources-columns');
    if (aiChatbot) aiChatbot.style.display = 'none';
    if (sourcesColumns) sourcesColumns.style.display = 'none';
    
    initializeEvidenceChatbot(type);
    if (window.updateCurrentAssistantType) window.updateCurrentAssistantType(type);
  }

  function initializeEvidenceChatbot(type) {
    const usernameElement = document.querySelector('.user-name, .username, [data-username]');
    const username = usernameElement ? usernameElement.textContent.trim() : 'there';
    const welcomeMessages = {
      'verse': `Hi ${username}! I am your AI Verse Assistant. Please add a verse name, number or quote for me to find.`,
      'historical': `Hi ${username}! I am your AI Historical Assistant. Please provide a historical event or context for me to research.`,
      'definition': `Hi ${username}! I am your AI Definition Assistant. Please provide a term or concept for me to define.`,
      'logic': `Hi ${username}! I am your AI Logic Assistant. Please provide a logical argument or reasoning for me to analyze.`
    };
    addAIEvidenceMessage(welcomeMessages[type] || `Hi ${username}! I am your AI Evidence Assistant. How can I help you?`, 'ai');
  }

  function addAIEvidenceMessage(message, sender) {
    const messagesContainer = document.getElementById('ai-evidence-chatbot-messages');
    if (!messagesContainer) return;
    const messageElement = document.createElement('div');
    messageElement.className = `ai-chatbot-message ${sender}`;
    messageElement.textContent = message;
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return messageElement;
  }

  function setupEvidenceChatbot() {
    const input = document.getElementById('ai-evidence-chatbot-input');
    const sendButton = document.getElementById('ai-evidence-chatbot-send');
    let currentAssistantType = null;
    let pendingEvidence = null;
    function sendMessage() {
      const message = input.value.trim();
      if (!message) return;
      addAIEvidenceMessage(message, 'user');
      input.value = '';
      // If we have pending evidence and user responds to confirmation
      if (pendingEvidence && (message.toLowerCase().includes('yes') || message.toLowerCase().includes('y'))) {
        if (currentEvidenceUnit && currentAssistantType) {
          // Add the evidence to the evidence unit
          addEvidenceToUnit(pendingEvidence, currentAssistantType);
          pendingEvidence = null;
          return;
        }
      }
      if (pendingEvidence && (message.toLowerCase().includes('no') || message.toLowerCase().includes('n'))) {
        addAIEvidenceMessage('Evidence not added. You can try another one.', 'ai');
        pendingEvidence = null;
        return;
      }
      if (currentEvidenceUnit && currentAssistantType) {
        generateEvidenceWithQuery(currentAssistantType, message);
      }
    }
    if (sendButton) sendButton.addEventListener('click', sendMessage);
    if (input) input.addEventListener('keypress', function(e) { if (e.key === 'Enter') sendMessage(); });
    window.updateCurrentAssistantType = function(type) { currentAssistantType = type; };
    window.setPendingEvidence = function(evidence) { pendingEvidence = evidence; };
  }

  function generateEvidenceWithQuery(sectionType, userQuery) {
    const claimContent = document.getElementById('validated-claim-display').value;
    const thinkingMessage = addAIEvidenceMessage('Thinking...', 'ai');
    fetch('/claims/generate_ai_evidence', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ claim_content: claimContent, evidence_type: sectionType, user_query: userQuery })
    })
    .then(response => response.json())
    .then(data => {
      if (thinkingMessage) thinkingMessage.remove();
      if (data.success) {
        streamAIEvidenceResponse(data.evidence, sectionType);
      } else {
        addAIEvidenceMessage('Could not verify the provided evidence. Please try another one.', 'ai');
      }
    })
    .catch(error => {
      if (thinkingMessage) thinkingMessage.remove();
      addAIEvidenceMessage('Could not verify the provided evidence. Please try another one.', 'ai');
    });
  }

  function addEvidenceToUnit(evidence, sectionType) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === currentEvidenceUnit.id);
    if (!evidenceUnit) return;
    
    // Initialize section as array if it doesn't exist
    if (!evidenceUnit.sections[sectionType]) {
      evidenceUnit.sections[sectionType] = [];
    }
    
    // First, try to find an empty verse section to populate
    let targetSectionIndex = -1;
    let targetSectionElement = null;
    
    if (sectionType === 'verse') {
      // Look for existing empty verse sections
      const existingSections = document.querySelectorAll(`[data-section-type="verse"][data-unit-id="${currentEvidenceUnit.id}"]`);
      existingSections.forEach((section, index) => {
        const contentElement = section.querySelector('.evidence-section-content');
        const placeholder = contentElement.querySelector('.evidence-section-placeholder');
        if (placeholder && targetSectionIndex === -1) {
          // This is the first empty section, use it
          targetSectionIndex = index;
          targetSectionElement = section;
        }
      });
    }
    
    if (targetSectionElement) {
      // Use existing empty section
      const sectionId = targetSectionElement.id.replace('evidence-section-', '');
      const sectionIndex = parseInt(targetSectionElement.getAttribute('data-section-index'));
      
      // Update the section element with the new content
      const contentElement = targetSectionElement.querySelector('.evidence-section-content');
      contentElement.innerHTML = `<div class="evidence-section-details">${evidence.details}</div>`;
      
      // Update the evidence unit data
      evidenceUnit.sections[sectionType][sectionIndex] = {
        id: sectionId,
        type: sectionType,
        content: evidence.content,
        details: evidence.details,
        expanded: true,
        sources: evidence.sources
      };
    } else {
      // Create a new section element
      const sectionId = Date.now();
      const sectionsContainer = document.getElementById(`evidence-sections-${currentEvidenceUnit.id}`);
      const sectionElement = document.createElement('div');
      sectionElement.className = 'evidence-section';
      sectionElement.id = `evidence-section-${sectionId}`;
      sectionElement.setAttribute('data-section-type', sectionType);
      sectionElement.setAttribute('data-unit-id', currentEvidenceUnit.id);
      
      // Count actual filled sections to get correct index
      const filledSections = evidenceUnit.sections[sectionType].filter(section => section.content || section.details);
      const newIndex = filledSections.length;
      sectionElement.setAttribute('data-section-index', newIndex);
      
      const sectionTitle = getSectionTitle(sectionType, newIndex + 1);
      sectionElement.innerHTML = `
        <div class="evidence-section-header" onclick="toggleEvidenceSection(${sectionId})">
          <div class="evidence-section-title">${sectionTitle}</div>
          <div class="evidence-section-actions">
            <button type="button" class="toggle-section-btn" onclick="event.stopPropagation(); toggleEvidenceSection(${sectionId})">
              <i class="fa fa-chevron-down"></i>
            </button>
            <button type="button" class="remove-section-btn" onclick="event.stopPropagation(); removeEvidenceSection(${currentEvidenceUnit.id}, '${sectionType}', ${newIndex})">
              <i class="fa fa-times"></i>
            </button>
          </div>
        </div>
        <div class="evidence-section-content expanded">
          <div class="evidence-section-details">${evidence.details}</div>
        </div>
      `;
      
      sectionsContainer.appendChild(sectionElement);
      
      // Add evidence to the evidence unit
      evidenceUnit.sections[sectionType].push({
        id: sectionId,
        type: sectionType,
        content: evidence.content,
        details: evidence.details,
        expanded: true,
        sources: evidence.sources
      });
    }
    
    // Update the combined evidence field
    updateCombinedEvidenceField();
    
    // Update sources hash
    updateEvidenceSourcesHash();
    
    // Update available section buttons
    updateAvailableSectionButtons(currentEvidenceUnit.id);
  }

  function removeEvidenceSection(unitId, sectionType, index) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit || !evidenceUnit.sections[sectionType] || index < 0 || index >= evidenceUnit.sections[sectionType].length) return;
    
    // Remove from array
    evidenceUnit.sections[sectionType].splice(index, 1);
    
    // Remove from DOM
    const sectionElement = document.querySelector(`[data-section-type="${sectionType}"][data-unit-id="${unitId}"][data-section-index="${index}"]`);
    if (sectionElement) { 
      sectionElement.remove(); 
    }
    
    // Renumber remaining sections
    const remainingSections = document.querySelectorAll(`[data-section-type="${sectionType}"][data-unit-id="${unitId}"]`);
    remainingSections.forEach((section, newIndex) => {
      section.setAttribute('data-section-index', newIndex);
      const titleElement = section.querySelector('.evidence-section-title');
      if (titleElement) {
        titleElement.textContent = getSectionTitle(sectionType, newIndex + 1);
      }
      const removeBtn = section.querySelector('.remove-section-btn');
      if (removeBtn) {
        removeBtn.onclick = (e) => {
          e.stopPropagation();
          removeEvidenceSection(unitId, sectionType, newIndex);
        };
      }
    });
    
    updateAvailableSectionButtons(unitId);
    updateCombinedEvidenceField();
    updateEvidenceSourcesHash();
  }

  function streamAIEvidenceResponse(evidence, sectionType) {
    // Create a temporary evidence object for streaming
    const tempEvidence = { 
      id: Date.now(), 
      type: sectionType, 
      content: '', 
      details: '', 
      expanded: true,
      sources: []
    };
    
    let content = '';
    let details = '';
    let streamText = '';
    
    switch(sectionType) {
      case 'verse':
        content = `${evidence.verse_reference}\n\n${evidence.translation}`;
        const verseSources = Array.isArray(evidence.sources) ? evidence.sources : (evidence.source ? [evidence.source] : ['Unknown']);
        details = `
          <div class="detail-row">
            <span class="detail-label">Reference:</span>
            <span class="detail-value">${evidence.verse_reference}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${verseSources.join(', ')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Original Text:</span>
            <span class="detail-value">${evidence.original_text}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Translation:</span>
            <span class="detail-value">${evidence.translation}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Explanation:</span>
            <span class="detail-value">${evidence.explanation}</span>
          </div>
        `;
        streamText = `${evidence.verse_reference}\n\nSource: ${verseSources.join(', ')}\n\nOriginal: ${evidence.original_text}\n\nTranslation: ${evidence.translation}\n\nExplanation: ${evidence.explanation}`;
        tempEvidence.sources = verseSources;
        break;
      case 'historical':
        content = `${evidence.historical_event}\n\n${evidence.description}`;
        const historicalSources = Array.isArray(evidence.sources) ? evidence.sources : (evidence.source ? [evidence.source] : ['Historical']);
        details = `
          <div class="detail-row">
            <span class="detail-label">Historical Event:</span>
            <span class="detail-value">${evidence.historical_event}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${historicalSources.join(', ')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Description:</span>
            <span class="detail-value">${evidence.description}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Relevance:</span>
            <span class="detail-value">${evidence.relevance}</span>
          </div>
        `;
        streamText = `${evidence.historical_event}\n\nSource: ${historicalSources.join(', ')}\n\nDescription: ${evidence.description}\n\nRelevance: ${evidence.relevance}`;
        tempEvidence.sources = historicalSources;
        break;
      case 'definition':
        content = `${evidence.term}\n\n${evidence.definition}`;
        const definitionSources = Array.isArray(evidence.sources) ? evidence.sources : (evidence.source ? [evidence.source] : ['Historical']);
        details = `
          <div class="detail-row">
            <span class="detail-label">Term:</span>
            <span class="detail-value">${evidence.term}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${definitionSources.join(', ')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Definition:</span>
            <span class="detail-value">${evidence.definition}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Etymology:</span>
            <span class="detail-value">${evidence.etymology}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Usage Context:</span>
            <span class="detail-value">${evidence.usage_context}</span>
          </div>
        `;
        streamText = `${evidence.term}\n\nSource: ${definitionSources.join(', ')}\n\nDefinition: ${evidence.definition}\n\nEtymology: ${evidence.etymology}\n\nUsage Context: ${evidence.usage_context}`;
        tempEvidence.sources = definitionSources;
        break;
      case 'logic':
        content = `${evidence.premise}\n\n${evidence.reasoning}\n\n${evidence.conclusion}`;
        const logicSources = Array.isArray(evidence.sources) ? evidence.sources : (evidence.source ? [evidence.source] : ['Historical']);
        details = `
          <div class="detail-row">
            <span class="detail-label">Premise:</span>
            <span class="detail-value">${evidence.premise}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${logicSources.join(', ')}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Reasoning:</span>
            <span class="detail-value">${evidence.reasoning}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Conclusion:</span>
            <span class="detail-value">${evidence.conclusion}</span>
          </div>
        `;
        streamText = `${evidence.premise}\n\nSource: ${logicSources.join(', ')}\n\nReasoning: ${evidence.reasoning}\n\nConclusion: ${evidence.conclusion}`;
        tempEvidence.sources = logicSources;
        break;
    }
    
    tempEvidence.content = content;
    tempEvidence.details = details;
    
    // Store the evidence for confirmation
    window.setPendingEvidence(tempEvidence);
    
    // Stream the response in the AI assistant
    streamTextInEvidenceAssistant(streamText, sectionType);
  }

  function streamTextInEvidenceAssistant(text, sectionType) {
    const messagesContainer = document.getElementById('ai-evidence-chatbot-messages');
    const messageElement = document.createElement('div');
    messageElement.className = 'ai-chatbot-message ai';
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    let i = 0;
    function streamChar() {
      if (i < text.length) {
        messageElement.innerHTML = text.slice(0, i + 1).replace(/\n/g, '<br>');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        i++;
        setTimeout(streamChar, 30);
      } else {
        // Ask user if they want to add this evidence AFTER streaming is complete
        setTimeout(() => {
          const sectionTypeNames = { 'verse': 'verse', 'historical': 'historical evidence', 'definition': 'definition', 'logic': 'logical evidence' };
          addAIEvidenceMessage(`Do you want me to add this ${sectionTypeNames[sectionType]} to your evidence? (Yes/No)`, 'ai');
        }, 500);
        
        setTimeout(() => {
          updateAvailableSectionButtons(currentEvidenceUnit.id);
        }, 500);
      }
    }
    streamChar();
  }

  // --- Setup on DOMContentLoaded ---
  document.addEventListener('DOMContentLoaded', function() {
    setupEvidenceControls();
    setupEvidenceChatbot();
  });
  // [EVIDENCE UNITS & AI EVIDENCE ASSISTANT LOGIC END]

  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, setting up form handlers');
        showClaimStepAndResetIllustration();
    console.log('showClaimStepAndResetIllustration completed');
    
    // OLD AI EVIDENCE CHATBOT DISABLED - Now using new evidence units system
    // The new system is handled in _evidence_units_js.html.erb
    // Event listeners are now managed by the new evidence units system
    
    const form = document.getElementById('claim-form');
    const validateButton = document.getElementById('validate-claim');
    const submitButton = document.getElementById('submit-claim');
    const claimInput = form.querySelector('[name="claim[content]"]');
    const errorMessage = document.querySelector('.error-message');
    const evidenceError = document.querySelector('.evidence-error');
    const submitLoader = document.getElementById('submit-loader-overlay');

    // Validate claim button handler
    validateButton.addEventListener('click', function() {
      console.log('Validate button clicked');
      const content = claimInput.value;
      
      if (!content.trim()) {
        errorMessage.textContent = 'Please enter a claim';
        errorMessage.style.display = 'block';
        return;
      }

      validateButton.disabled = true;
      validateButton.textContent = 'Validating...';

      console.log('Sending validation request for:', content);
      fetch('/claims/validate_claim', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({ claim: { content: content } })
      })
      .then(response => response.json())
      .then(data => {
        console.log('Validation response:', data);
        if (data.valid) {
          window.validatedClaim = data.cleaned_claim;
          claimInput.value = data.cleaned_claim;
          errorMessage.style.display = 'none';
          
          // Handle duplicate detection
          if (typeof handleDuplicateDetection === 'function') {
            const hasDuplicates = handleDuplicateDetection(data);
            // If duplicates are found, don't proceed to evidence step
            if (hasDuplicates) {
              return;
            }
          }
          
          // Hide chatbot, show illustration if previously hidden
          document.getElementById('ai-chatbot-container').style.display = 'none';
          showEvidenceStep();
        } else {
          console.log('Claim validation failed, showing AI chatbot');
          // Hide illustration, show chatbot
          const aiChatbotContainer = document.getElementById('ai-chatbot-container');
          if (aiChatbotContainer) {
            aiChatbotContainer.style.display = 'flex';
            console.log('AI chatbot container displayed');
          } else {
            console.error('AI chatbot container not found!');
          }
          // Start chatbot with failed claim and error message
          startAIChatbot(content, data.error);
        }
      })
      .catch(error => {
        console.error('Validation error:', error);
        errorMessage.textContent = 'An error occurred while validating the claim';
        errorMessage.style.display = 'block';
      })
      .finally(() => {
        validateButton.disabled = false;
        validateButton.textContent = 'Continue';
      });
    });

    // Form submission handler
    form.addEventListener('submit', function(e) {
      console.log('Form submit triggered');
      e.preventDefault();
      
      // Get evidence units from the combined field
      const combinedEvidenceField = document.getElementById('combined-evidence-field');
      let evidenceUnits = [];
      
      if (combinedEvidenceField && combinedEvidenceField.value) {
        try {
          evidenceUnits = JSON.parse(combinedEvidenceField.value);
        } catch (error) {
          console.error('Error parsing evidence units:', error);
        }
      }

      if (evidenceUnits.length === 0) {
        console.log('Evidence missing');
        evidenceError.textContent = 'Please add at least one evidence';
        evidenceError.style.display = 'block';
        return;
      }

      if (!window.validatedClaim) {
        console.log('No validated claim found');
        errorMessage.textContent = 'Please validate your claim first';
        showClaimStep();
        return;
      }

      // Set the final values
      claimInput.value = window.validatedClaim;
      
      // Update evidence sources hash first
      updateEvidenceSourcesHash();
      
      // Use the current state of the source hashes (respecting user's drag and drop choices)
      const primarySources = Array.from(primarySourcesHash);
      const secondarySources = Array.from(secondarySourcesHash);
      
      console.log('Form submission - Hash state:');
      console.log('Primary sources hash:', primarySources);
      console.log('Secondary sources hash:', secondarySources);
      
      // Update hidden fields for sources
      const primarySourcesField = document.getElementById('primary-sources-field');
      const secondarySourcesField = document.getElementById('secondary-sources-field');
      
      if (primarySourcesField) {
        primarySourcesField.value = JSON.stringify(primarySources);
        console.log('Updated primary sources field with:', primarySources);
      }
      
      if (secondarySourcesField) {
        secondarySourcesField.value = JSON.stringify(secondarySources);
        console.log('Updated secondary sources field with:', secondarySources);
      }
      
      console.log('Submitting form with:', {
        finalClaim: claimInput.value,
        evidenceUnits: evidenceUnits,
        primarySources: primarySources,
        secondarySources: secondarySources
      });

      // Show loader before submitting
      if(submitLoader) {
        const saveAsDraftField = document.getElementById('save-as-draft-field');
        const loaderText = submitLoader.querySelector('.loader-text');

        if (loaderText && saveAsDraftField && saveAsDraftField.value === 'true') {
          loaderText.textContent = 'Saving claim...';
        } else if (loaderText) {
          loaderText.textContent = 'Submitting claim...';
        }
        
        submitLoader.classList.add('active');
      }

      // Disable the submit button
      submitButton.disabled = true;
      
      // Submit the form
      form.submit();
    });



    // Chatbot input handler
    const aiChatbotSend = document.getElementById('ai-chatbot-send');
    const aiChatbotInput = document.getElementById('ai-chatbot-input');
    
    if (aiChatbotSend) {
      aiChatbotSend.addEventListener('click', function() {
        console.log('AI chatbot send button clicked');
        const input = document.getElementById('ai-chatbot-input');
        const text = input.value.trim();
        if (!text) return;
        console.log('Sending message:', text);
        appendChatMessage('user', text);
        input.value = '';
        if (isHelpRequest(text)) {
          streamAIClaimGuidance(text);
        } else {
          streamAIResponse(text, '');
        }
      });
    }
    
    if (aiChatbotInput) {
      aiChatbotInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const sendBtn = document.getElementById('ai-chatbot-send');
          if (sendBtn) sendBtn.click();
        }
      });
    }

    // Evidence validation is now handled by _new_claim_js.html.erb
    // Old evidence system has been removed

    // Also hide AI Evidence Assistant on form submit
    form.addEventListener('submit', function(e) {
      const aiEvidenceContainer = document.getElementById('ai-evidence-chatbot-container');
      if (aiEvidenceContainer) aiEvidenceContainer.style.display = 'none';
    });
  });

  function openDeleteClaimModal(claimId) {
    var modal = document.getElementById('delete-claim-modal');
    var form = document.getElementById('delete-claim-form');
    form.action = '/claims/' + claimId;
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
  function closeDeleteClaimModal() {
    var modal = document.getElementById('delete-claim-modal');
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.my-claim-delete-link').forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        openDeleteClaimModal(this.getAttribute('data-claim-id'));
      });
    });
  });

  function startAIChatbot(failedClaim, errorMsg) {
    const messagesDiv = document.getElementById('ai-chatbot-messages');
          messagesDiv.innerHTML = '';
      appendChatMessage('user', failedClaim);
      // Start streaming AI response
      streamAIResponse(failedClaim, errorMsg);
      }

    function streamAIResponse(failedClaim, errorMsg) {
    console.log('streamAIResponse called with:', failedClaim, errorMsg);
    // Show AI is typing...
    appendChatMessage('ai', 'Thinking...');
    // Replace with your backend endpoint for streaming AI (e.g. /ai/claim_suggestion)
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    if (!messagesDiv) {
      console.error('Messages div not found for streaming');
      return;
    }
    fetch('/ai/claim_suggestion', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ claim: failedClaim, error: errorMsg })
    })
    .then(async response => {
      console.log('AI response status:', response.status);
      if (!response.body) throw new Error('No response body');
      // Remove 'Thinking...' message
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
          console.log('Received chunk:', chunk);
          // Show letter by letter
          while (buffer.length > 0) {
            aiMsg += buffer[0];
            aiDiv.textContent = aiMsg;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            buffer = buffer.slice(1);
            await new Promise(r => setTimeout(r, 12)); // Typing speed (ms per char)
          }
        }
      }
      console.log('AI streaming completed');
    })
    .catch(err => {
      console.error('AI response error:', err);
      // Remove 'Thinking...' message if it exists
      const thinkingMessage = messagesDiv.querySelector('.ai-chatbot-message.ai:last-child');
      if (thinkingMessage && thinkingMessage.textContent === 'Thinking...') {
        thinkingMessage.remove();
      }
      appendChatMessage('ai', 'Sorry, there was a problem getting suggestions.');
    });
  }

  function formatEvidenceBox(obj) {
    let out = '';
    if (obj.reference) out += obj.reference + '\n';
    if (obj.original) out += 'Original: ' + obj.original + '\n';
    if (obj.translation) out += 'Translation: ' + obj.translation;
    return out.trim();
  }

  // Helper functions for evidence sections
  function getSectionTitle(sectionType, count) {
    const displayName = getSectionDisplayName(sectionType);
    return `${displayName} ${count}`;
  }

  function getSectionDisplayName(sectionType) {
    const displayNames = {
      'verse': 'Verse',
      'historical': 'Historical',
      'definition': 'Definition',
      'logic': 'Logic'
    };
    return displayNames[sectionType] || sectionType;
  }
<% end %>