<%= javascript_tag do %>
  window.validatedClaim = null;

  function showClaimStep() {
    console.log('Showing claim step');
    document.getElementById('claim-step').style.display = 'block';
    document.getElementById('evidence-step').style.display = 'none';
    const errorMessage = document.querySelector('.error-message');
    if (errorMessage) {
      errorMessage.style.display = 'none';
      errorMessage.textContent = '';
    }
    // Show the AI claim assistant greeting
    startAIChatbotGreeting();
  }

  function showClaimStepAndResetIllustration() {
    console.log('showClaimStepAndResetIllustration called');
    showClaimStep();
    // Show AI Claim Assistant, hide AI Evidence Assistant
    const aiChatbotContainer = document.getElementById('ai-chatbot-container');
    const aiEvidenceContainer = document.getElementById('ai-evidence-chatbot-container');
    
    console.log('AI Chatbot container:', aiChatbotContainer);
    console.log('AI Evidence container:', aiEvidenceContainer);
    
    if (aiChatbotContainer) {
      aiChatbotContainer.style.display = 'flex';
      console.log('AI Chatbot container display set to flex');
    } else {
      console.error('AI Chatbot container not found!');
    }
    
    if (aiEvidenceContainer) {
      aiEvidenceContainer.style.display = 'none';
    }
    
    const sourcesColumns = document.getElementById('sources-columns');
    if (sourcesColumns) sourcesColumns.style.display = 'none';
    const errorMessage = document.querySelector('.error-message');
    if (errorMessage) {
      errorMessage.style.display = 'none';
      errorMessage.textContent = '';
    }
    // Show the AI Claim Assistant greeting only on initial load or when returning to claim step
    startAIChatbotGreeting();
  }

  function showEvidenceStep() {
    console.log('Showing evidence step');
    document.getElementById('claim-step').style.display = 'none';
    document.getElementById('evidence-step').style.display = 'block';
    
    const validatedClaimDisplay = document.getElementById('validated-claim-display');
    if (validatedClaimDisplay && window.validatedClaim) {
      validatedClaimDisplay.value = window.validatedClaim;
    }
    // Only show evidence assistant
    document.getElementById('ai-evidence-chatbot-container').style.display = 'flex';
    document.getElementById('ai-chatbot-container').style.display = 'none';
    // Reset evidence assistant chat
    startAIEvidenceChatbot();

    // Make evidence section editable and show Add Evidence button
    const evidencesContainer = document.getElementById('evidences-container');
    // Evidence units are now handled by _evidence_units_js.html.erb
    // Old evidence system has been removed
    // Hide sources columns
    const sourcesColumns = document.getElementById('sources-columns');
    if (sourcesColumns) sourcesColumns.style.display = 'none';
  }

  // --- AI Evidence Assistant logic ---
  let aiEvidenceChatHistory = [
    { role: "system", content: "You are an expert assistant for evidence suggestion. Help users find a single, clear, and relevant piece of evidence for their claim. Respond conversationally, and always end with: 'Do you want me to add this as evidence? (Yes/No)'" }
  ];

  function appendEvidenceChatMessage(role, text) {
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
    const msg = document.createElement('div');
    msg.className = 'ai-chatbot-message ' + (role === 'user' ? 'user' : 'ai');
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  }

  let lastEvidenceSuggestion = '';

  function startAIEvidenceChatbot() {
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
    messagesDiv.innerHTML = '';
    appendEvidenceChatMessage('ai', 'Hi! I am your AI Evidence Assistant. Ask me anything about the evidence you want to add.');
    lastEvidenceSuggestion = '';
    aiEvidenceChatHistory = [
      { role: "system", content: "You are an expert assistant for evidence suggestion. Help users find a single, clear, and relevant piece of evidence for their claim. Respond conversationally, and always end with: 'Do you want me to add this as evidence? (Yes/No)'" }
    ];
  }

  function streamAIEvidenceResponse(userMsg) {
    appendEvidenceChatMessage('ai', 'Thinking...');
    aiEvidenceChatHistory.push({ role: 'user', content: userMsg });
    const messagesDiv = document.getElementById('ai-evidence-chatbot-messages');
          fetch('/ai/evidence_suggestion', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector("[name='csrf-token']").content
        },
        body: JSON.stringify({ messages: aiEvidenceChatHistory })
      })
    .then(async response => {
      if (!response.body) throw new Error('No response body');
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
        }
      }
      // Try to parse the buffered response as JSON
      let evidenceObj = null;
      try {
        // Replace smart quotes with standard quotes
        buffer = buffer.replace(/[""]/g, '"').replace(/['']/g, "'");
        // Try to extract the first {...} block from the buffer
        const match = buffer.match(/{[\s\S]*}/);
        if (match) {
          evidenceObj = JSON.parse(match[0]);
        } else {
          throw new Error('No JSON found');
        }
      } catch (e) {
        appendEvidenceChatMessage('ai', 'Sorry, I could not understand the evidence response.');
        return;
      }
      let formatted = '';
      if (evidenceObj.reference) formatted += evidenceObj.reference + '\n';
      if (evidenceObj.original) formatted += 'Original: ' + evidenceObj.original + '\n';
      if (evidenceObj.translation) formatted += 'Translation: ' + evidenceObj.translation + '\n';
      if (evidenceObj.explanation) formatted += '\n' + evidenceObj.explanation + '\n';
      formatted = formatted.trim() + '\n\nDo you want me to add this as evidence? (Yes/No)';
      // Stream the formatted string character by character into a single chat message
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let i = 0;
      function streamChar() {
        if (i <= formatted.length) {
          aiDiv.innerHTML = formatted.slice(0, i).replace(/\n/g, '<br>');
          messagesDiv.scrollTop = messagesDiv.scrollHeight;
          i++;
          setTimeout(streamChar, 12);
        }
      }
      streamChar();
      lastEvidenceSuggestion = JSON.stringify({
        reference: evidenceObj.reference || '',
        original: evidenceObj.original || '',
        translation: evidenceObj.translation || ''
      });
      aiEvidenceChatHistory.push({ role: 'assistant', content: buffer });
    })
    .catch(err => {
      appendEvidenceChatMessage('ai', 'Sorry, there was a problem getting suggestions.');
    });
  }

  // --- AI Chatbot logic ---
  function appendChatMessage(role, text) {
    console.log('appendChatMessage called with:', role, text);
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    console.log('Messages div in appendChatMessage:', messagesDiv);
    if (messagesDiv) {
      const msg = document.createElement('div');
      msg.className = 'ai-chatbot-message ' + (role === 'user' ? 'user' : 'ai');
      msg.textContent = text;
      messagesDiv.appendChild(msg);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      console.log('Message appended successfully');
    } else {
      console.error('Messages div not found in appendChatMessage!');
    }
  }

  function startAIChatbotGreeting() {
        const userName = document.getElementById('claim-form-wrapper')?.dataset.userName || 'there';
    const messagesDiv = document.getElementById('ai-chatbot-messages');
          messagesDiv.innerHTML = '';
      appendChatMessage('ai', `Hi ${userName}, I am your AI Claim Assistant. You can enter your claim in the claim box, or ask me for help or clarification about how to build a strong claim.`);
        }

  function isHelpRequest(text) {
    return /\b(how|what|help|guide|advice|should|can|could|\?)\b/i.test(text);
  }

  function streamAIClaimGuidance(userMsg) {
        appendChatMessage('ai', 'Let me help you...');
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    fetch('/ai/claim_guidance', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ question: userMsg })
    })
    .then(async response => {
      if (!response.body) throw new Error('No response body');
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
          while (buffer.length > 0) {
            aiMsg += buffer[0];
            aiDiv.textContent = aiMsg;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            buffer = buffer.slice(1);
            await new Promise(r => setTimeout(r, 12));
          }
        }
      }
    })
    .catch(err => {
      appendChatMessage('ai', 'Sorry, there was a problem getting guidance.');
    });
  }

  // [EVIDENCE UNITS & AI EVIDENCE ASSISTANT LOGIC START]
  // --- Evidence Units State ---
  let evidenceUnits = [];
  let currentEvidenceUnit = null;
  let evidenceSourcesHash = new Set(); // Track unique sources from evidence units

  // Available sources for validation
  const AVAILABLE_SOURCES = ['Quran', 'Tanakh', 'Catholic', 'Ethiopian', 'Protestant', 'Historical'];

  function setupEvidenceControls() {
    const addEvidenceBtn = document.getElementById('add-evidence-btn');
    const evidenceTypeSelector = document.getElementById('evidence-type-selector');
    const evidenceTypeOptions = document.querySelectorAll('.evidence-type-option');

    // Show/hide evidence type selector
    if (addEvidenceBtn && evidenceTypeSelector) {
      addEvidenceBtn.addEventListener('click', function() {
        if (evidenceTypeSelector.style.display === 'none') {
          evidenceTypeSelector.style.display = 'block';
          addEvidenceBtn.innerHTML = '<i class="fa fa-times"></i> Cancel';
        } else {
          evidenceTypeSelector.style.display = 'none';
          addEvidenceBtn.innerHTML = '<i class="fa fa-plus"></i> Add Evidence';
        }
      });
    }

    // Handle evidence type selection
    evidenceTypeOptions.forEach(option => {
      option.addEventListener('click', function() {
        const evidenceType = this.getAttribute('data-type');
        createEvidenceUnit(evidenceType);
        // Hide selector and reset button
        evidenceTypeSelector.style.display = 'none';
        addEvidenceBtn.innerHTML = '<i class="fa fa-plus"></i> Add Evidence';
      });
    });
  }

  function createEvidenceUnit(initialType) {
    const unitId = Date.now();
    const evidenceUnit = {
      id: unitId,
      sections: {},
      expanded: true
    };
    evidenceUnits.push(evidenceUnit);
    currentEvidenceUnit = evidenceUnit;
    // Create evidence unit element
    const container = document.getElementById('evidences-container');
    const unitElement = document.createElement('div');
    unitElement.className = 'evidence-unit';
    unitElement.id = `evidence-unit-${unitId}`;
    unitElement.innerHTML = `
      <div class="evidence-unit-header" onclick="toggleEvidenceUnit(${unitId})">
        <div class="evidence-unit-title">Evidence ${evidenceUnits.length}</div>
        <div class="evidence-unit-actions">
          <button type="button" class="toggle-evidence-unit-btn" onclick="event.stopPropagation(); toggleEvidenceUnit(${unitId})">
            <i class="fa fa-chevron-down"></i>
          </button>
          <button type="button" class="remove-evidence-unit-btn" onclick="event.stopPropagation(); removeEvidenceUnit(${unitId})">
            <i class="fa fa-times"></i>
          </button>
        </div>
      </div>
      <div class="evidence-unit-content expanded">
        <div class="evidence-sections" id="evidence-sections-${unitId}"></div>
        <div class="evidence-section-options" id="evidence-section-options-${unitId}"></div>
      </div>
    `;
    container.appendChild(unitElement);
    addEvidenceSection(unitId, initialType);
    updateAvailableSectionButtons(unitId);
    showEvidenceChatbot(initialType);
    updateCombinedEvidenceField();
  }

  function addEvidenceSection(unitId, sectionType) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit) return;
    const sectionId = Date.now();
    evidenceUnit.sections[sectionType] = {
      id: sectionId,
      type: sectionType,
      content: '',
      details: '',
      expanded: true
    };
    const sectionsContainer = document.getElementById(`evidence-sections-${unitId}`);
    const sectionElement = document.createElement('div');
    sectionElement.className = 'evidence-section';
    sectionElement.id = `evidence-section-${sectionId}`;
    sectionElement.innerHTML = `
      <div class="evidence-section-header" onclick="toggleEvidenceSection(${sectionId})">
        <div class="evidence-section-title">${sectionType}</div>
        <div class="evidence-section-actions">
          <button type="button" class="toggle-section-btn" onclick="event.stopPropagation(); toggleEvidenceSection(${sectionId})">
            <i class="fa fa-chevron-down"></i>
          </button>
          <button type="button" class="remove-section-btn" onclick="event.stopPropagation(); removeEvidenceSection(${unitId}, '${sectionType}')">
            <i class="fa fa-times"></i>
          </button>
        </div>
      </div>
      <div class="evidence-section-content expanded" id="evidence-section-content-${sectionId}">
        <div class="evidence-section-placeholder">
          <i class="fa fa-comment"></i> Use the AI ${sectionType} Assistant to generate evidence
        </div>
      </div>
    `;
    sectionElement.setAttribute('data-section-type', sectionType);
    sectionElement.setAttribute('data-unit-id', unitId);
    sectionsContainer.appendChild(sectionElement);
    showEvidenceChatbot(sectionType);
    updateAvailableSectionButtons(unitId);
  }

  function updateAvailableSectionButtons(unitId) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit) return;
    const optionsContainer = document.getElementById(`evidence-section-options-${unitId}`);
    if (!optionsContainer) return;
    optionsContainer.innerHTML = '';
    const availableTypes = ['verse', 'historical', 'definition', 'logic'].filter(type => !evidenceUnit.sections[type]);
    availableTypes.forEach(type => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'add-section-btn';
      button.setAttribute('data-section-type', type);
      button.onclick = function() { addEvidenceSection(unitId, type); };
      const buttonText = { 'verse': 'Add Verse', 'historical': 'Add Historical', 'definition': 'Add Definition', 'logic': 'Add Logic' };
      button.innerHTML = `<i class="fa fa-plus"></i> ${buttonText[type]}`;
      optionsContainer.appendChild(button);
    });
  }

  function toggleEvidenceUnit(unitId) {
    const unitElement = document.getElementById(`evidence-unit-${unitId}`);
    const contentElement = unitElement.querySelector('.evidence-unit-content');
    const toggleBtn = unitElement.querySelector('.toggle-evidence-unit-btn');
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (evidenceUnit) {
      evidenceUnit.expanded = !evidenceUnit.expanded;
      if (evidenceUnit.expanded) {
        contentElement.classList.add('expanded');
        toggleBtn.classList.remove('collapsed');
      } else {
        contentElement.classList.remove('expanded');
        toggleBtn.classList.add('collapsed');
      }
    }
  }

  function toggleEvidenceSection(sectionId) {
    const sectionElement = document.getElementById(`evidence-section-${sectionId}`);
    const contentElement = sectionElement.querySelector('.evidence-section-content');
    const toggleBtn = sectionElement.querySelector('.toggle-section-btn');
    if (contentElement.classList.contains('expanded')) {
      contentElement.classList.remove('expanded');
      toggleBtn.classList.add('collapsed');
    } else {
      contentElement.classList.add('expanded');
      toggleBtn.classList.remove('collapsed');
    }
  }

  function removeEvidenceUnit(unitId) {
    evidenceUnits = evidenceUnits.filter(unit => unit.id !== unitId);
    const unitElement = document.getElementById(`evidence-unit-${unitId}`);
    if (unitElement) { unitElement.remove(); }
    updateCombinedEvidenceField();
    updateEvidenceSourcesHash();
  }

  function removeEvidenceSection(unitId, sectionType) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === unitId);
    if (!evidenceUnit || !evidenceUnit.sections[sectionType]) return;
    delete evidenceUnit.sections[sectionType];
    const sectionElement = document.querySelector(`[data-section-type="${sectionType}"][data-unit-id="${unitId}"]`);
    if (sectionElement) { sectionElement.remove(); }
    updateAvailableSectionButtons(unitId);
    updateCombinedEvidenceField();
    updateEvidenceSourcesHash();
  }

  function updateCombinedEvidenceField() {
    const combinedField = document.getElementById('combined-evidence-field');
    const evidenceData = evidenceUnits.map(unit => ({ id: unit.id, sections: unit.sections }));
    if (combinedField) combinedField.value = JSON.stringify(evidenceData);
  }

  // --- Source Management Functions ---
  function updateEvidenceSourcesHash() {
    evidenceSourcesHash.clear();
    
    evidenceUnits.forEach(unit => {
      Object.values(unit.sections).forEach(section => {
        if (section.source && AVAILABLE_SOURCES.includes(section.source)) {
          evidenceSourcesHash.add(section.source);
        }
      });
    });
    
    console.log('Updated evidence sources hash:', Array.from(evidenceSourcesHash));
  }

  function determinePrimaryAndSecondarySources() {
    const allSources = Array.from(evidenceSourcesHash);
    console.log('All sources from hash:', allSources);
    
    // Define primary sources (religious sources)
    const primarySourceTypes = ['Quran', 'Tanakh', 'Catholic', 'Ethiopian', 'Protestant'];
    
    // Categorize sources
    const primarySources = allSources.filter(source => 
      primarySourceTypes.includes(source)
    );
    
    const secondarySources = allSources.filter(source => 
      !primarySourceTypes.includes(source)
    );
    
    console.log('Primary sources:', primarySources);
    console.log('Secondary sources:', secondarySources);
    
    return {
      primary: primarySources,
      secondary: secondarySources
    };
  }

  function createSourceElement(source) {
    const sourceElement = document.createElement('div');
    sourceElement.className = 'source-item';
    sourceElement.setAttribute('draggable', 'true');
    sourceElement.setAttribute('data-source', source);
    sourceElement.innerHTML = `
      <span class="source-name">${source}</span>
    `;
    return sourceElement;
  }

  function addDragListeners(element) {
    element.addEventListener('dragstart', function(e) {
      e.dataTransfer.setData('text/plain', this.getAttribute('data-source'));
      this.classList.add('dragging');
    });
    
    element.addEventListener('dragend', function(e) {
      this.classList.remove('dragging');
      // Remove dragover class from all sources lists
      document.querySelectorAll('.sources-list').forEach(list => {
        list.classList.remove('dragover');
      });
    });
    
    element.addEventListener('dragover', function(e) {
      e.preventDefault();
    });
    
    element.addEventListener('drop', function(e) {
      e.preventDefault();
      const source = e.dataTransfer.getData('text/plain');
      const sourceElement = document.querySelector(`[data-source="${source}"]`);
      const targetList = this.closest('.sources-list');
      
      if (sourceElement && targetList && sourceElement.parentNode !== targetList) {
        targetList.appendChild(sourceElement);
        updateHiddenFields();
      }
      
      // Remove dragover class
      document.querySelectorAll('.sources-list').forEach(list => {
        list.classList.remove('dragover');
      });
    });
  }

  // Add drag and drop listeners to sources lists
  function setupSourcesDragAndDrop() {
    const sourcesLists = document.querySelectorAll('.sources-list');
    
    sourcesLists.forEach(list => {
      list.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('dragover');
      });
      
      list.addEventListener('dragleave', function(e) {
        // Only remove class if we're leaving the list entirely
        if (!this.contains(e.relatedTarget)) {
          this.classList.remove('dragover');
        }
      });
      
      list.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('dragover');
      });
    });
  }

  function updateSourcesUI() {
    console.log('updateSourcesUI called');
    const sources = determinePrimaryAndSecondarySources();
    console.log('Sources to display:', sources);
    
    // Hide AI assistant and show sources columns
    const aiChatbotContainer = document.getElementById('ai-chatbot-container');
    const aiEvidenceChatbotContainer = document.getElementById('ai-evidence-chatbot-container');
    const sourcesColumns = document.getElementById('sources-columns');
    
    if (aiChatbotContainer) {
      console.log('Hiding AI chatbot container');
      aiChatbotContainer.style.display = 'none';
    }
    if (aiEvidenceChatbotContainer) {
      console.log('Hiding AI evidence chatbot container');
      aiEvidenceChatbotContainer.style.display = 'none';
    }
    if (sourcesColumns) {
      console.log('Showing sources columns');
      sourcesColumns.style.display = 'flex';
    }
    
    // Update primary sources
    const primarySourcesList = document.getElementById('primary-sources-list');
    if (primarySourcesList) {
      console.log('Updating primary sources list with:', sources.primary);
      primarySourcesList.innerHTML = '';
      sources.primary.forEach(source => {
        console.log('Creating source element for:', source);
        const sourceElement = createSourceElement(source);
        addDragListeners(sourceElement);
        primarySourcesList.appendChild(sourceElement);
      });
    } else {
      console.error('Primary sources list not found');
    }
    
    // Update secondary sources - show all available sources that are not in primary
    const secondarySourcesList = document.getElementById('secondary-sources-list');
    if (secondarySourcesList) {
      console.log('Updating secondary sources list');
      secondarySourcesList.innerHTML = '';
      
      // Get all available sources that are not in primary
      const availableSecondarySources = AVAILABLE_SOURCES.filter(source => 
        !sources.primary.includes(source)
      );
      
      console.log('Available secondary sources:', availableSecondarySources);
      
      availableSecondarySources.forEach(source => {
        console.log('Creating source element for:', source);
        const sourceElement = createSourceElement(source);
        addDragListeners(sourceElement);
        secondarySourcesList.appendChild(sourceElement);
      });
    } else {
      console.error('Secondary sources list not found');
    }
    
    // Setup drag and drop for sources lists
    setupSourcesDragAndDrop();
    
    // Update hidden fields
    updateHiddenFields();
    console.log('updateSourcesUI completed');
  }

  function updateHiddenFields() {
    const primarySourcesList = document.getElementById('primary-sources-list');
    const secondarySourcesList = document.getElementById('secondary-sources-list');
    const primarySourcesField = document.getElementById('primary-sources-field');
    const secondarySourcesField = document.getElementById('secondary-sources-field');
    
    if (primarySourcesList && primarySourcesField) {
      const primarySources = Array.from(primarySourcesList.querySelectorAll('.source-item')).map(item => item.getAttribute('data-source'));
      primarySourcesField.value = JSON.stringify(primarySources);
      console.log('Updated primary sources field:', primarySources);
    }
    
    if (secondarySourcesList && secondarySourcesField) {
      const secondarySources = Array.from(secondarySourcesList.querySelectorAll('.source-item')).map(item => item.getAttribute('data-source'));
      secondarySourcesField.value = JSON.stringify(secondarySources);
      console.log('Updated secondary sources field:', secondarySources);
    }
  }

  // --- AI Evidence Assistant Chatbot ---
  function showEvidenceChatbot(type) {
    const chatbotContainer = document.getElementById('ai-evidence-chatbot-container');
    const chatbotHeader = document.getElementById('ai-evidence-chatbot-header');
    const chatbotMessages = document.getElementById('ai-evidence-chatbot-messages');
    const headers = { 'verse': 'AI Verse Assistant', 'historical': 'AI Historical Assistant', 'definition': 'AI Definition Assistant', 'logic': 'AI Logic Assistant' };
    if (chatbotHeader) chatbotHeader.textContent = headers[type] || 'AI Evidence Assistant';
    if (chatbotMessages) chatbotMessages.innerHTML = '';
    if (chatbotContainer) chatbotContainer.style.display = 'flex';
    
    // Hide AI Claim Assistant and sources columns
    const aiChatbot = document.getElementById('ai-chatbot-container');
    const sourcesColumns = document.getElementById('sources-columns');
    if (aiChatbot) aiChatbot.style.display = 'none';
    if (sourcesColumns) sourcesColumns.style.display = 'none';
    
    initializeEvidenceChatbot(type);
    if (window.updateCurrentAssistantType) window.updateCurrentAssistantType(type);
  }

  function initializeEvidenceChatbot(type) {
    const usernameElement = document.querySelector('.user-name, .username, [data-username]');
    const username = usernameElement ? usernameElement.textContent.trim() : 'there';
    const welcomeMessages = {
      'verse': `Hi ${username}! I am your AI Verse Assistant. Please add a verse name, number or quote for me to find.`,
      'historical': `Hi ${username}! I am your AI Historical Assistant. Please provide a historical event or context for me to research.`,
      'definition': `Hi ${username}! I am your AI Definition Assistant. Please provide a term or concept for me to define.`,
      'logic': `Hi ${username}! I am your AI Logic Assistant. Please provide a logical argument or reasoning for me to analyze.`
    };
    addAIEvidenceMessage(welcomeMessages[type] || `Hi ${username}! I am your AI Evidence Assistant. How can I help you?`, 'ai');
  }

  function addAIEvidenceMessage(message, sender) {
    const messagesContainer = document.getElementById('ai-evidence-chatbot-messages');
    if (!messagesContainer) return;
    const messageElement = document.createElement('div');
    messageElement.className = `ai-chatbot-message ${sender}`;
    messageElement.textContent = message;
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    return messageElement;
  }

  function setupEvidenceChatbot() {
    const input = document.getElementById('ai-evidence-chatbot-input');
    const sendButton = document.getElementById('ai-evidence-chatbot-send');
    let currentAssistantType = null;
    let pendingEvidence = null;
    function sendMessage() {
      const message = input.value.trim();
      if (!message) return;
      addAIEvidenceMessage(message, 'user');
      input.value = '';
      // If we have pending evidence and user responds to confirmation
      if (pendingEvidence && (message.toLowerCase().includes('yes') || message.toLowerCase().includes('y'))) {
        if (currentEvidenceUnit && currentAssistantType) {
          const existingSection = document.querySelector(`[data-section-type="${currentAssistantType}"][data-unit-id="${currentEvidenceUnit.id}"]`);
          if (existingSection && pendingEvidence.details) {
            const contentElement = existingSection.querySelector('.evidence-section-content');
            contentElement.innerHTML = `
              <div class="evidence-section-details">${pendingEvidence.details}</div>
            `;
          }
          
          // Update the evidence unit with the pending evidence data
          const evidenceUnit = evidenceUnits.find(unit => unit.id === currentEvidenceUnit.id);
          if (evidenceUnit && pendingEvidence) {
            evidenceUnit.sections[currentAssistantType] = {
              id: pendingEvidence.id,
              type: pendingEvidence.type,
              content: pendingEvidence.content,
              details: pendingEvidence.details,
              expanded: true,
              source: pendingEvidence.source
            };
            
            // Update the combined evidence field
            updateCombinedEvidenceField();
          }
          
          const sectionTypeNames = { 'verse': 'verse', 'historical': 'historical evidence', 'definition': 'definition', 'logic': 'logical evidence' };
          addAIEvidenceMessage(`${sectionTypeNames[currentAssistantType]} added successfully! You can add more ${sectionTypeNames[currentAssistantType]} for me to find.`, 'ai');
          pendingEvidence = null;
          updateEvidenceSourcesHash();
          return;
        }
      }
      if (pendingEvidence && (message.toLowerCase().includes('no') || message.toLowerCase().includes('n'))) {
        addAIEvidenceMessage('Evidence not added. You can try another one.', 'ai');
        pendingEvidence = null;
        return;
      }
      if (currentEvidenceUnit && currentAssistantType) {
        generateEvidenceWithQuery(currentAssistantType, message);
      }
    }
    if (sendButton) sendButton.addEventListener('click', sendMessage);
    if (input) input.addEventListener('keypress', function(e) { if (e.key === 'Enter') sendMessage(); });
    window.updateCurrentAssistantType = function(type) { currentAssistantType = type; };
    window.setPendingEvidence = function(evidence) { pendingEvidence = evidence; };
  }

  function generateEvidenceWithQuery(sectionType, userQuery) {
    const claimContent = document.getElementById('validated-claim-display').value;
    const thinkingMessage = addAIEvidenceMessage('Thinking...', 'ai');
    fetch('/claims/generate_ai_evidence', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ claim_content: claimContent, evidence_type: sectionType, user_query: userQuery })
    })
    .then(response => response.json())
    .then(data => {
      if (thinkingMessage) thinkingMessage.remove();
      if (data.success) {
        streamAIEvidenceResponse(data.evidence, sectionType);
      } else {
        addAIEvidenceMessage('Could not verify the provided evidence. Please try another one.', 'ai');
      }
    })
    .catch(error => {
      if (thinkingMessage) thinkingMessage.remove();
      addAIEvidenceMessage('Could not verify the provided evidence. Please try another one.', 'ai');
    });
  }

  function streamAIEvidenceResponse(evidence, sectionType) {
    const evidenceUnit = evidenceUnits.find(unit => unit.id === currentEvidenceUnit.id);
    if (!evidenceUnit) return;
    const existingSection = document.querySelector(`[data-section-type="${sectionType}"][data-unit-id="${currentEvidenceUnit.id}"]`);
    if (!existingSection) return;
    const sectionId = existingSection.id.replace('evidence-section-', '');
    evidenceUnit.sections[sectionType] = { id: sectionId, type: sectionType, content: '', details: '', expanded: true };
    let content = '';
    let details = '';
    let streamText = '';
    switch(sectionType) {
      case 'verse':
        content = `${evidence.verse_reference}\n\n${evidence.translation}`;
        details = `
          <div class="detail-row">
            <span class="detail-label">Reference:</span>
            <span class="detail-value">${evidence.verse_reference}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${evidence.source}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Original Text:</span>
            <span class="detail-value">${evidence.original_text}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Translation:</span>
            <span class="detail-value">${evidence.translation}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Explanation:</span>
            <span class="detail-value">${evidence.explanation}</span>
          </div>
        `;
        streamText = `${evidence.verse_reference}\n\nSource: ${evidence.source}\n\nOriginal: ${evidence.original_text}\n\nTranslation: ${evidence.translation}\n\nExplanation: ${evidence.explanation}`;
        // Store source in evidence unit
        evidenceUnit.sections[sectionType].source = evidence.source;
        break;
      case 'historical':
        content = `${evidence.historical_event}\n\n${evidence.description}`;
        details = `
          <div class="detail-row">
            <span class="detail-label">Historical Event:</span>
            <span class="detail-value">${evidence.historical_event}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${evidence.source}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Description:</span>
            <span class="detail-value">${evidence.description}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Relevance:</span>
            <span class="detail-value">${evidence.relevance}</span>
          </div>
        `;
        streamText = `${evidence.historical_event}\n\nSource: ${evidence.source}\n\nDescription: ${evidence.description}\n\nRelevance: ${evidence.relevance}`;
        evidenceUnit.sections[sectionType].source = evidence.source;
        break;
      case 'definition':
        content = `${evidence.term}\n\n${evidence.definition}`;
        details = `
          <div class="detail-row">
            <span class="detail-label">Term:</span>
            <span class="detail-value">${evidence.term}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${evidence.source}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Definition:</span>
            <span class="detail-value">${evidence.definition}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Etymology:</span>
            <span class="detail-value">${evidence.etymology}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Usage Context:</span>
            <span class="detail-value">${evidence.usage_context}</span>
          </div>
        `;
        streamText = `${evidence.term}\n\nSource: ${evidence.source}\n\nDefinition: ${evidence.definition}\n\nEtymology: ${evidence.etymology}\n\nUsage Context: ${evidence.usage_context}`;
        evidenceUnit.sections[sectionType].source = evidence.source;
        break;
      case 'logic':
        content = `${evidence.premise}\n\n${evidence.reasoning}\n\n${evidence.conclusion}`;
        details = `
          <div class="detail-row">
            <span class="detail-label">Premise:</span>
            <span class="detail-value">${evidence.premise}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Source:</span>
            <span class="detail-value">${evidence.source}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Reasoning:</span>
            <span class="detail-value">${evidence.reasoning}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Conclusion:</span>
            <span class="detail-value">${evidence.conclusion}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Logical Form:</span>
            <span class="detail-value">${evidence.logical_form}</span>
          </div>
        `;
        streamText = `${evidence.premise}\n\nSource: ${evidence.source}\n\nReasoning: ${evidence.reasoning}\n\nConclusion: ${evidence.conclusion}\n\nLogical Form: ${evidence.logical_form}`;
        evidenceUnit.sections[sectionType].source = evidence.source;
        break;
    }
    evidenceUnit.sections[sectionType].content = content;
    evidenceUnit.sections[sectionType].details = details;
    streamTextInEvidenceAssistant(streamText, sectionType);
  }

  function streamTextInEvidenceAssistant(text, sectionType) {
    const messagesContainer = document.getElementById('ai-evidence-chatbot-messages');
    const messageElement = document.createElement('div');
    messageElement.className = 'ai-chatbot-message ai';
    messagesContainer.appendChild(messageElement);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    let i = 0;
    function streamChar() {
      if (i < text.length) {
        messageElement.innerHTML = text.slice(0, i + 1).replace(/\n/g, '<br>');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        i++;
        setTimeout(streamChar, 30);
      } else {
        const sectionTypeNames = { 'verse': 'verse', 'historical': 'historical evidence', 'definition': 'definition', 'logic': 'logical evidence' };
        setTimeout(() => {
          addAIEvidenceMessage(`Do you want me to add this ${sectionTypeNames[sectionType]} to your evidence? (Yes/No)`, 'ai');
          if (window.setPendingEvidence) {
            const evidenceUnit = evidenceUnits.find(unit => unit.id === currentEvidenceUnit.id);
            if (evidenceUnit && evidenceUnit.sections[sectionType]) {
              window.setPendingEvidence(evidenceUnit.sections[sectionType]);
            }
          }
          updateAvailableSectionButtons(currentEvidenceUnit.id);
        }, 500);
      }
    }
    streamChar();
  }

  // --- Setup on DOMContentLoaded ---
  document.addEventListener('DOMContentLoaded', function() {
    setupEvidenceControls();
    setupEvidenceChatbot();
  });
  // [EVIDENCE UNITS & AI EVIDENCE ASSISTANT LOGIC END]

  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, setting up form handlers');
        showClaimStepAndResetIllustration();
    console.log('showClaimStepAndResetIllustration completed');
    
    // OLD AI EVIDENCE CHATBOT DISABLED - Now using new evidence units system
    // The new system is handled in _evidence_units_js.html.erb
    // Event listeners are now managed by the new evidence units system
    
    const form = document.getElementById('claim-form');
    const validateButton = document.getElementById('validate-claim');
    const submitButton = document.getElementById('submit-claim');
    const claimInput = form.querySelector('[name="claim[content]"]');
    const errorMessage = document.querySelector('.error-message');
    const evidenceError = document.querySelector('.evidence-error');
    const submitLoader = document.getElementById('submit-loader-overlay');

    // Validate claim button handler
    validateButton.addEventListener('click', function() {
      console.log('Validate button clicked');
      const content = claimInput.value;
      
      if (!content.trim()) {
        errorMessage.textContent = 'Please enter a claim';
        errorMessage.style.display = 'block';
        return;
      }

      validateButton.disabled = true;
      validateButton.textContent = 'Validating...';

      console.log('Sending validation request for:', content);
      fetch('/claims/validate_claim', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify({ claim: { content: content } })
      })
      .then(response => response.json())
      .then(data => {
        console.log('Validation response:', data);
        if (data.valid) {
          window.validatedClaim = data.cleaned_claim;
          claimInput.value = data.cleaned_claim;
          errorMessage.style.display = 'none';
          
          // Handle duplicate detection
          if (typeof handleDuplicateDetection === 'function') {
            const hasDuplicates = handleDuplicateDetection(data);
            // If duplicates are found, don't proceed to evidence step
            if (hasDuplicates) {
              return;
            }
          }
          
          // Hide chatbot, show illustration if previously hidden
          document.getElementById('ai-chatbot-container').style.display = 'none';
          showEvidenceStep();
        } else {
          console.log('Claim validation failed, showing AI chatbot');
          // Hide illustration, show chatbot
          const aiChatbotContainer = document.getElementById('ai-chatbot-container');
          if (aiChatbotContainer) {
            aiChatbotContainer.style.display = 'flex';
            console.log('AI chatbot container displayed');
          } else {
            console.error('AI chatbot container not found!');
          }
          // Start chatbot with failed claim and error message
          startAIChatbot(content, data.error);
        }
      })
      .catch(error => {
        console.error('Validation error:', error);
        errorMessage.textContent = 'An error occurred while validating the claim';
        errorMessage.style.display = 'block';
      })
      .finally(() => {
        validateButton.disabled = false;
        validateButton.textContent = 'Continue';
      });
    });

    // Form submission handler
    form.addEventListener('submit', function(e) {
      console.log('Form submit triggered');
      e.preventDefault();
      
      // Get evidence units from the combined field
      const combinedEvidenceField = document.getElementById('combined-evidence-field');
      let evidenceUnits = [];
      
      if (combinedEvidenceField && combinedEvidenceField.value) {
        try {
          evidenceUnits = JSON.parse(combinedEvidenceField.value);
        } catch (error) {
          console.error('Error parsing evidence units:', error);
        }
      }

      if (evidenceUnits.length === 0) {
        console.log('Evidence missing');
        evidenceError.textContent = 'Please add at least one evidence';
        evidenceError.style.display = 'block';
        return;
      }

      if (!window.validatedClaim) {
        console.log('No validated claim found');
        errorMessage.textContent = 'Please validate your claim first';
        showClaimStep();
        return;
      }

      // Set the final values
      claimInput.value = window.validatedClaim;
      
      // Update evidence sources hash and determine sources
      updateEvidenceSourcesHash();
      const sources = determinePrimaryAndSecondarySources();
      
      // Update hidden fields for sources
      const primarySourcesField = document.getElementById('primary-sources-field');
      const secondarySourcesField = document.getElementById('secondary-sources-field');
      
      if (primarySourcesField) {
        primarySourcesField.value = JSON.stringify(sources.primary);
      }
      
      if (secondarySourcesField) {
        secondarySourcesField.value = JSON.stringify(sources.secondary);
      }
      
      console.log('Submitting form with:', {
        finalClaim: claimInput.value,
        evidenceUnits: evidenceUnits,
        primarySources: sources.primary,
        secondarySources: sources.secondary
      });

      // Show loader before submitting
      if(submitLoader) {
        const saveAsDraftField = document.getElementById('save-as-draft-field');
        const loaderText = submitLoader.querySelector('.loader-text');

        if (loaderText && saveAsDraftField && saveAsDraftField.value === 'true') {
          loaderText.textContent = 'Saving claim...';
        } else if (loaderText) {
          loaderText.textContent = 'Submitting claim...';
        }
        
        submitLoader.classList.add('active');
      }

      // Disable the submit button
      submitButton.disabled = true;
      
      // Submit the form
      form.submit();
    });



    // Chatbot input handler
    const aiChatbotSend = document.getElementById('ai-chatbot-send');
    const aiChatbotInput = document.getElementById('ai-chatbot-input');
    
    if (aiChatbotSend) {
      aiChatbotSend.addEventListener('click', function() {
        console.log('AI chatbot send button clicked');
        const input = document.getElementById('ai-chatbot-input');
        const text = input.value.trim();
        if (!text) return;
        console.log('Sending message:', text);
        appendChatMessage('user', text);
        input.value = '';
        if (isHelpRequest(text)) {
          streamAIClaimGuidance(text);
        } else {
          streamAIResponse(text, '');
        }
      });
    }
    
    if (aiChatbotInput) {
      aiChatbotInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          const sendBtn = document.getElementById('ai-chatbot-send');
          if (sendBtn) sendBtn.click();
        }
      });
    }

    // Evidence validation is now handled by _new_claim_js.html.erb
    // Old evidence system has been removed

    // Also hide AI Evidence Assistant on form submit
    form.addEventListener('submit', function(e) {
      const aiEvidenceContainer = document.getElementById('ai-evidence-chatbot-container');
      if (aiEvidenceContainer) aiEvidenceContainer.style.display = 'none';
    });
  });

  function openDeleteClaimModal(claimId) {
    var modal = document.getElementById('delete-claim-modal');
    var form = document.getElementById('delete-claim-form');
    form.action = '/claims/' + claimId;
    modal.style.display = 'flex';
    document.body.classList.add('modal-open');
  }
  function closeDeleteClaimModal() {
    var modal = document.getElementById('delete-claim-modal');
    modal.style.display = 'none';
    document.body.classList.remove('modal-open');
  }
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.my-claim-delete-link').forEach(function(link) {
      link.addEventListener('click', function(e) {
        e.preventDefault();
        openDeleteClaimModal(this.getAttribute('data-claim-id'));
      });
    });
  });

  function startAIChatbot(failedClaim, errorMsg) {
    const messagesDiv = document.getElementById('ai-chatbot-messages');
          messagesDiv.innerHTML = '';
      appendChatMessage('user', failedClaim);
      // Start streaming AI response
      streamAIResponse(failedClaim, errorMsg);
      }

    function streamAIResponse(failedClaim, errorMsg) {
    console.log('streamAIResponse called with:', failedClaim, errorMsg);
    // Show AI is typing...
    appendChatMessage('ai', 'Thinking...');
    // Replace with your backend endpoint for streaming AI (e.g. /ai/claim_suggestion)
    const messagesDiv = document.getElementById('ai-chatbot-messages');
    if (!messagesDiv) {
      console.error('Messages div not found for streaming');
      return;
    }
    fetch('/ai/claim_suggestion', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
      },
      body: JSON.stringify({ claim: failedClaim, error: errorMsg })
    })
    .then(async response => {
      console.log('AI response status:', response.status);
      if (!response.body) throw new Error('No response body');
      // Remove 'Thinking...' message
      messagesDiv.removeChild(messagesDiv.lastChild);
      const reader = response.body.getReader();
      let aiMsg = '';
      let done = false;
      const aiDiv = document.createElement('div');
      aiDiv.className = 'ai-chatbot-message ai';
      messagesDiv.appendChild(aiDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      let buffer = '';
      while (!done) {
        const { value, done: doneReading } = await reader.read();
        done = doneReading;
        if (value) {
          const chunk = new TextDecoder().decode(value);
          buffer += chunk;
          console.log('Received chunk:', chunk);
          // Show letter by letter
          while (buffer.length > 0) {
            aiMsg += buffer[0];
            aiDiv.textContent = aiMsg;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            buffer = buffer.slice(1);
            await new Promise(r => setTimeout(r, 12)); // Typing speed (ms per char)
          }
        }
      }
      console.log('AI streaming completed');
    })
    .catch(err => {
      console.error('AI response error:', err);
      // Remove 'Thinking...' message if it exists
      const thinkingMessage = messagesDiv.querySelector('.ai-chatbot-message.ai:last-child');
      if (thinkingMessage && thinkingMessage.textContent === 'Thinking...') {
        thinkingMessage.remove();
      }
      appendChatMessage('ai', 'Sorry, there was a problem getting suggestions.');
    });
  }

  function formatEvidenceBox(obj) {
    let out = '';
    if (obj.reference) out += obj.reference + '\n';
    if (obj.original) out += 'Original: ' + obj.original + '\n';
    if (obj.translation) out += 'Translation: ' + obj.translation;
    return out.trim();
  }
<% end %>