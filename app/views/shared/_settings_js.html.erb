<script>
function showAvatarLoader() {
  document.getElementById('avatar-loader').style.display = 'flex';
}
function hideAvatarLoader() {
  document.getElementById('avatar-loader').style.display = 'none';
}
function removeAvatarAndPreviewAndSubmit() {
  console.log('removeAvatarAndPreviewAndSubmit called');
  // Show custom confirmation modal
  showConfirmationModal(
    'Are you sure you want to delete your avatar?',
    function() {
      console.log('Avatar deletion confirmed');
      var preview = document.querySelector('.settings-avatar-img-lg');
      if (preview) {
        preview.src = '/assets/default-avatar.png';
      }
      document.getElementById('remove-avatar-field').value = 'true';
      showAvatarLoader();
      document.getElementById('avatar-upload-input').closest('form').submit();
    }
  );
}
// Global variable to store cropper instance
let avatarCropper = null;
let selectedAvatarFile = null;
let backgroundCropper = null;
let selectedBackgroundFile = null;
let lastSliderValue = 1; // Track last slider value for smooth zoom
let lastBackgroundSliderValue = 1; // Track last slider value for background zoom
let isUserDraggingSlider = false; // Track if user is actively dragging the slider
let isUserDraggingBackgroundSlider = false; // Track if user is actively dragging the background slider
let isUsingZoomButtons = false; // Track if user is using zoom buttons
let isUsingBackgroundZoomButtons = false; // Track if user is using background zoom buttons

document.getElementById('avatar-upload-input').addEventListener('change', function() {
  const file = this.files[0];
  if (file) {
    // Clear any existing errors
    clearError('avatar');
    
    // Check file type (size limit removed - images will be automatically compressed)
    const allowedTypes = ['image/png', 'image/jpg', 'image/jpeg'];
    if (!allowedTypes.includes(file.type)) {
      showError('Avatar must be a PNG or JPG image. Please select a valid image file.', 'avatar');
      this.value = ''; // Clear the input
      return;
    }
    
    // Store the selected file
    selectedAvatarFile = file;
    
    // Show the cropping modal instead of submitting immediately
    showImageCropModal(file);
  }
});

// Background image functionality
function showBackgroundLoader() {
  document.getElementById('background-loader').style.display = 'flex';
}

function hideBackgroundLoader() {
  document.getElementById('background-loader').style.display = 'none';
}

function removeBackgroundAndPreviewAndSubmit() {
  console.log('removeBackgroundAndPreviewAndSubmit called');
  // Show custom confirmation modal
  showConfirmationModal(
    'Are you sure you want to delete your background image?',
    function() {
      console.log('Background deletion confirmed');
      // Hide the background image and show placeholder
      var preview = document.querySelector('.settings-background-img');
      var placeholder = document.querySelector('.settings-background-placeholder');
      
      if (preview) {
        preview.style.display = 'none';
      }
      if (placeholder) {
        placeholder.style.display = 'flex';
      }
      
      document.getElementById('remove-background-field').value = 'true';
      showBackgroundLoader();
      document.getElementById('background-upload-input').closest('form').submit();
    }
  );
}

document.getElementById('background-upload-input').addEventListener('change', function() {
  const file = this.files[0];
  if (file) {
    // Clear any existing errors
    clearError('background');
    
    // Check file type (size limit removed - images will be automatically compressed)
    const allowedTypes = ['image/png', 'image/jpg', 'image/jpeg'];
    if (!allowedTypes.includes(file.type)) {
      showError('Background image must be a PNG or JPG image. Please select a valid image file.', 'background');
      this.value = ''; // Clear the input
      return;
    }
    
    // Store the selected file
    selectedBackgroundFile = file;
    
    // Show the cropping modal instead of submitting immediately
    showBackgroundCropModal(file);
  }
});

// Error display functions
function showError(message, type = 'avatar') {
  // Remove any existing error messages
  const existingError = document.querySelector(`.${type}-error-message`);
  if (existingError) {
    existingError.remove();
  }
  
  // Create error message element
  const errorDiv = document.createElement('div');
  errorDiv.className = `${type}-error-message`;
  errorDiv.style.cssText = `
    background: #fef2f2;
    border: 1px solid #fecaca;
    color: #dc2626;
    padding: 12px 16px;
    border-radius: 8px;
    margin-top: 8px;
    font-size: 0.95rem;
    display: flex;
    align-items: center;
    gap: 8px;
  `;
  
  errorDiv.innerHTML = `
    <i class="fas fa-exclamation-triangle" style="color: #dc2626;"></i>
    <span>${message}</span>
  `;
  
  // Insert after the upload button
  const uploadButton = document.querySelector(`.settings-${type}-update`);
  if (uploadButton) {
    uploadButton.parentNode.insertBefore(errorDiv, uploadButton.nextSibling);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, 10000);
  }
}

function clearError(type = 'avatar') {
  const existingError = document.querySelector(`.${type}-error-message`);
  if (existingError) {
    existingError.remove();
  }
}

// Custom Confirmation Modal Functions
function showConfirmationModal(message, onConfirm) {
  console.log('showConfirmationModal called with message:', message);
  const modal = document.getElementById('confirmation-modal');
  const messageElement = document.getElementById('confirmation-message');
  const confirmBtn = document.getElementById('confirmation-confirm-btn');
  
  console.log('Modal elements found:', {
    modal: !!modal,
    messageElement: !!messageElement,
    confirmBtn: !!confirmBtn
  });
  
  if (!modal || !messageElement || !confirmBtn) {
    console.error('Modal elements not found!');
    return;
  }
  
  // Set the message
  messageElement.textContent = message;
  
  // Remove any existing event listeners
  const newConfirmBtn = confirmBtn.cloneNode(true);
  confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
  
  // Add new event listener
  newConfirmBtn.addEventListener('click', function() {
    console.log('Confirm button clicked');
    closeConfirmationModal();
    onConfirm();
  });
  
  // Show the modal with smooth animation
  console.log('Adding show class to modal');
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeConfirmationModal() {
  const modal = document.getElementById('confirmation-modal');
  modal.classList.remove('show');
  
  // Wait for animation to complete before hiding
  setTimeout(() => {
    document.body.style.overflow = '';
  }, 250);
}

// Close modal when clicking overlay
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('confirmation-overlay')) {
    closeConfirmationModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const modal = document.getElementById('confirmation-modal');
    if (modal.classList.contains('show')) {
      closeConfirmationModal();
    }
  }
});

// Banner background image upload handler
const bannerBackgroundInput = document.getElementById('banner-background-upload-input');
if (bannerBackgroundInput) {
  bannerBackgroundInput.addEventListener('change', function() {
    const file = this.files[0];
    if (file) {
      // Clear any existing errors
      clearError('background');
      
      // Check file type
      const allowedTypes = ['image/png', 'image/jpg', 'image/jpeg'];
      if (!allowedTypes.includes(file.type)) {
        showError('Background image must be a PNG or JPG image. Please select a valid image file.', 'background');
        this.value = '';
        return;
      }
      
      // Store the selected file
      selectedBackgroundFile = file;
      
      // Show the cropping modal instead of submitting immediately
      showBackgroundCropModal(file);
    }
  });
}

function removeBannerBackgroundAndSubmit() {
  showConfirmationModal(
    'Are you sure you want to delete your background image?',
    function() {
      // Find the form in the edit page
      const form = document.querySelector('.settings-form');
      if (form) {
        const removeField = form.querySelector('#remove-background-field');
        if (removeField) {
          removeField.value = 'true';
        }
        
        showBackgroundLoader();
        form.submit();
      }
    }
  );
}

// Avatar Options Modal Functions
function showAvatarOptionsModal() {
  const modal = document.getElementById('avatar-options-modal');
  if (modal) {
    modal.classList.add('show');
    document.body.style.overflow = 'hidden';
  }
}

function closeAvatarOptionsModal() {
  const modal = document.getElementById('avatar-options-modal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
  }
}

function uploadAvatarFromModal() {
  closeAvatarOptionsModal();
  document.getElementById('avatar-upload-input').click();
}

function deleteAvatarFromModal() {
  closeAvatarOptionsModal();
  showConfirmationModal(
    'Are you sure you want to remove your profile picture?',
    function() {
      console.log('Avatar deletion confirmed');
      var preview = document.querySelector('.settings-avatar-img-lg');
      if (preview) {
        preview.src = '/assets/default-avatar.png';
      }
      var avatarImg = document.querySelector('.settings-avatar-img');
      if (avatarImg) {
        avatarImg.src = '/assets/default-avatar.png';
      }
      document.getElementById('remove-avatar-field').value = 'true';
      showAvatarLoader();
      document.querySelector('.settings-form').submit();
    }
  );
}

// Close avatar options modal when clicking overlay
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('avatar-options-overlay')) {
    closeAvatarOptionsModal();
  }
});

// Close avatar options modal with Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const modal = document.getElementById('avatar-options-modal');
    if (modal && modal.classList.contains('show')) {
      closeAvatarOptionsModal();
    }
  }
});

// Image Cropping Modal Functions
function showImageCropModal(file) {
  const modal = document.getElementById('image-crop-modal');
  const preview = document.getElementById('image-crop-preview');
  
  if (!modal || !preview) {
    // Fallback to old behavior if modal doesn't exist
    document.getElementById('remove-avatar-field').value = 'false';
    showAvatarLoader();
    document.getElementById('avatar-upload-input').closest('form').submit();
    return;
  }
  
  // Create object URL for the image
  const imageUrl = URL.createObjectURL(file);
  preview.src = imageUrl;
  
  // Show the modal
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  
  // Initialize cropper after image loads
  const initializeCropper = function() {
    // Destroy existing cropper if any
    if (avatarCropper) {
      avatarCropper.destroy();
      avatarCropper = null;
    }
    
    // Initialize new cropper with circular aspect ratio for avatars
    avatarCropper = new Cropper(preview, {
      aspectRatio: 1, // Square/circular crop
      viewMode: 1,
      dragMode: 'move',
      autoCropArea: 0.8,
      restore: false,
      guides: true,
      center: true,
      highlight: false,
      cropBoxMovable: true,
      cropBoxResizable: true,
      toggleDragModeOnDblclick: false,
      minCropBoxWidth: 100,
      minCropBoxHeight: 100,
      zoomable: true,
      scalable: false,
      rotatable: true,
      ready: function() {
        // Reset slider tracking
        lastSliderValue = 1;
        isUserDraggingSlider = false;
        isUsingZoomButtons = false;
        
        // Add event listeners to track slider dragging
        const zoomSlider = document.getElementById('image-crop-zoom-slider');
        if (zoomSlider) {
          // Track when user starts dragging
          zoomSlider.addEventListener('mousedown', function() {
            isUserDraggingSlider = true;
          });
          zoomSlider.addEventListener('touchstart', function() {
            isUserDraggingSlider = true;
          });
          
          // Track when user stops dragging
          zoomSlider.addEventListener('mouseup', function() {
            setTimeout(() => {
              isUserDraggingSlider = false;
            }, 100);
          });
          zoomSlider.addEventListener('touchend', function() {
            setTimeout(() => {
              isUserDraggingSlider = false;
            }, 100);
          });
        }
        
        // Update zoom slider when cropper is ready
        updateZoomSlider();
        updateZoomSliderProgress();
        updateZoomButtonsState();
        // Show drag hint initially
        showDragHint();
      },
      crop: function() {
        // Hide drag hint when user starts interacting
        hideDragHint();
        // Update zoom slider progress on crop
        updateZoomSliderProgress();
      },
      zoom: function() {
        // Only update slider if user is not actively dragging or using buttons
        if (!isUserDraggingSlider && !isUsingZoomButtons) {
          updateZoomSlider();
          updateZoomSliderProgress();
        }
      }
    });
    
    // Update zoom slider value
    updateZoomSlider();
  };
  
  // Check if image is already loaded
  if (preview.complete) {
    // Image already loaded, initialize immediately
    setTimeout(initializeCropper, 100);
  } else {
    // Wait for image to load
    preview.onload = initializeCropper;
  }
}

function closeImageCropModal() {
  const modal = document.getElementById('image-crop-modal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    
    // Clean up cropper
    if (avatarCropper) {
      avatarCropper.destroy();
      avatarCropper = null;
    }
    
    // Clean up object URL
    const preview = document.getElementById('image-crop-preview');
    if (preview && preview.src) {
      URL.revokeObjectURL(preview.src);
      preview.src = '';
    }
    
    // Clear file input
    const fileInput = document.getElementById('avatar-upload-input');
    if (fileInput) {
      fileInput.value = '';
    }
    
    // Reset slider tracking
    lastSliderValue = 1;
    selectedAvatarFile = null;
  }
}

function saveCroppedImage() {
  if (!avatarCropper || !selectedAvatarFile) {
    closeImageCropModal();
    return;
  }
  
  // Get cropped canvas
  const canvas = avatarCropper.getCroppedCanvas({
    width: 400,
    height: 400,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high',
  });
  
  if (!canvas) {
    showError('Failed to crop image. Please try again.', 'avatar');
    closeImageCropModal();
    return;
  }
  
  // Convert canvas to blob
  canvas.toBlob(function(blob) {
    if (!blob) {
      showError('Failed to process image. Please try again.', 'avatar');
      closeImageCropModal();
      return;
    }
    
    // Create a File object from the blob with the original filename
    const croppedFile = new File([blob], selectedAvatarFile.name, {
      type: selectedAvatarFile.type,
      lastModified: Date.now()
    });
    
    // Get the form
    const form = document.querySelector('.settings-form');
    if (!form) {
      showError('Form not found. Please try again.', 'avatar');
      closeImageCropModal();
      return;
    }
    
    // Get form action URL
    const formAction = form.action || form.getAttribute('action') || '/settings';
    
    // Get CSRF token
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || 
                     document.querySelector('input[name="authenticity_token"]')?.value || 
                     form.querySelector('input[name="authenticity_token"]')?.value;
    
    if (!csrfToken) {
      showError('Security token not found. Please refresh the page and try again.', 'avatar');
      closeImageCropModal();
      return;
    }
    
    // Create FormData from the form
    const formData = new FormData(form);
    
    // Remove existing avatar if any
    formData.delete('user[avatar]');
    
    // Add the cropped file
    formData.append('user[avatar]', croppedFile);
    
    // Set remove_avatar to false
    formData.set('remove_avatar', 'false');
    
    // Ensure CSRF token is in FormData (Rails expects it as a form field)
    const authToken = form.querySelector('input[name="authenticity_token"]');
    if (authToken) {
      formData.set('authenticity_token', authToken.value);
    }
    
    // Close the cropping modal
    closeImageCropModal();
    
    // Show loader
    showAvatarLoader();
    
    // Submit form via fetch
    // Note: Don't set Content-Type header - let browser set it with boundary for multipart/form-data
    fetch(formAction, {
      method: 'PATCH',
      body: formData,
      headers: {
        'X-CSRF-Token': csrfToken,
        'X-Requested-With': 'XMLHttpRequest'
      },
      credentials: 'same-origin'
    })
    .then(response => {
      if (response.redirected) {
        // If redirected, follow the redirect
        window.location.href = response.url;
      } else if (response.ok) {
        // If successful, reload the page to show the new avatar
        window.location.reload();
      } else {
        throw new Error('Upload failed with status: ' + response.status);
      }
    })
    .catch(error => {
      console.error('Error uploading image:', error);
      hideAvatarLoader();
      showError('Failed to upload image. Please try again.', 'avatar');
    });
  }, selectedAvatarFile.type, 0.95); // Use original file type and high quality
}

// Close image crop modal when clicking overlay
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('image-crop-overlay')) {
    closeImageCropModal();
  }
});

// Rotation function
function rotateImage(degrees) {
  if (avatarCropper) {
    avatarCropper.rotate(degrees);
  }
}

// Zoom functions
function zoomImage(ratio) {
  if (avatarCropper) {
    const zoomSlider = document.getElementById('image-crop-zoom-slider');
    if (zoomSlider) {
      const currentValue = parseFloat(zoomSlider.value) ?? 1;
      
      // Check limits before zooming
      // If trying to zoom in (+) and already at max (2), don't zoom
      if (ratio > 0 && currentValue >= 2) {
        return;
      }
      // If trying to zoom out (-) and already at min (0), don't zoom
      if (ratio < 0 && currentValue <= 0) {
        return;
      }
      
      isUsingZoomButtons = true;
      
      // Adjust slider value based on zoom ratio
      // Positive ratio (zoom in) increases slider, negative (zoom out) decreases
      const newValue = Math.max(0, Math.min(2, currentValue + (ratio * 2)));
      
      // Update slider value BEFORE zooming to prevent reset
      zoomSlider.value = newValue;
      lastSliderValue = newValue;
      updateZoomSliderProgress();
      updateZoomButtonsState();
    }
    
    // Apply zoom
    avatarCropper.zoom(ratio);
    
    // Reset flag after a short delay to allow zoom event to complete
    setTimeout(() => {
      isUsingZoomButtons = false;
    }, 150);
  }
}

// Update zoom buttons state based on slider position
function updateZoomButtonsState() {
  const zoomSlider = document.getElementById('image-crop-zoom-slider');
  const minusBtn = document.getElementById('image-crop-zoom-minus-btn');
  const plusBtn = document.getElementById('image-crop-zoom-plus-btn');
  
  if (zoomSlider && minusBtn && plusBtn) {
    const sliderValue = parseFloat(zoomSlider.value) ?? 1;
    
    // Disable minus button if at minimum (0)
    if (sliderValue <= 0) {
      minusBtn.disabled = true;
      minusBtn.style.opacity = '0.5';
      minusBtn.style.cursor = 'not-allowed';
    } else {
      minusBtn.disabled = false;
      minusBtn.style.opacity = '1';
      minusBtn.style.cursor = 'pointer';
    }
    
    // Disable plus button if at maximum (2)
    if (sliderValue >= 2) {
      plusBtn.disabled = true;
      plusBtn.style.opacity = '0.5';
      plusBtn.style.cursor = 'not-allowed';
    } else {
      plusBtn.disabled = false;
      plusBtn.style.opacity = '1';
      plusBtn.style.cursor = 'pointer';
    }
  }
}

function updateZoom(value) {
  if (avatarCropper) {
    isUserDraggingSlider = true;
    const sliderValue = parseFloat(value);
    
    // Calculate the difference from the last slider value
    const sliderDiff = sliderValue - lastSliderValue;
    
    // Map slider difference to zoom ratio
    // Slider range 0-2, where 1 is neutral (no zoom)
    // Each 0.1 slider change = 0.1 zoom ratio
    const zoomRatio = sliderDiff * 0.5; // Scale the zoom sensitivity
    
    // Apply zoom if there's a meaningful change
    if (Math.abs(zoomRatio) > 0.01) {
      avatarCropper.zoom(zoomRatio);
      lastSliderValue = sliderValue;
    }
    
    // Always update progress bar and button states to reflect current slider position
    updateZoomSliderProgress();
    updateZoomButtonsState();
    
    // Reset flag after a short delay
    setTimeout(() => {
      isUserDraggingSlider = false;
    }, 100);
  }
}

function updateZoomSliderProgress() {
  const zoomSlider = document.getElementById('image-crop-zoom-slider');
  if (zoomSlider) {
    // Always use the actual slider value for progress indicator
    // Use nullish coalescing to handle 0 correctly (0 is valid, null/undefined is not)
    const sliderValue = parseFloat(zoomSlider.value) ?? 1;
    // Calculate progress percentage for visual indicator (0-100%)
    // Clamp to ensure valid range
    const progress = Math.max(0, Math.min(100, (sliderValue / 2) * 100));
    zoomSlider.style.setProperty('--slider-progress', progress + '%');
    
    // Also update button states
    updateZoomButtonsState();
  }
}

function updateZoomSlider() {
  if (avatarCropper && !isUserDraggingSlider && !isUsingZoomButtons) {
    const zoomSlider = document.getElementById('image-crop-zoom-slider');
    if (zoomSlider) {
      // Only update if user is not actively dragging or using buttons
      // Track the current slider value (but don't change it)
      lastSliderValue = parseFloat(zoomSlider.value) ?? 1;
      updateZoomSliderProgress();
    }
  }
}

// Show/hide drag hint
function showDragHint() {
  const dragHint = document.querySelector('.image-crop-drag-hint');
  if (dragHint) {
    dragHint.style.opacity = '1';
    dragHint.style.visibility = 'visible';
  }
}

function hideDragHint() {
  const dragHint = document.querySelector('.image-crop-drag-hint');
  if (dragHint) {
    dragHint.style.opacity = '0';
    dragHint.style.visibility = 'hidden';
  }
}

// Close image crop modal with Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const modal = document.getElementById('image-crop-modal');
    if (modal && modal.classList.contains('show')) {
      closeImageCropModal();
    }
    const backgroundModal = document.getElementById('background-crop-modal');
    if (backgroundModal && backgroundModal.classList.contains('show')) {
      closeBackgroundCropModal();
    }
  }
});

// Background Image Cropping Modal Functions
function showBackgroundCropModal(file) {
  const modal = document.getElementById('background-crop-modal');
  const preview = document.getElementById('background-crop-preview');
  
  if (!modal || !preview) {
    // Fallback to old behavior if modal doesn't exist
    document.getElementById('remove-background-field').value = 'false';
    showBackgroundLoader();
    document.getElementById('background-upload-input').closest('form').submit();
    return;
  }
  
  // Create object URL for the image
  const imageUrl = URL.createObjectURL(file);
  preview.src = imageUrl;
  
  // Show the modal
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  
  // Initialize cropper after image loads
  const initializeBackgroundCropper = function() {
    // Destroy existing cropper if any
    if (backgroundCropper) {
      backgroundCropper.destroy();
      backgroundCropper = null;
    }
    
    // Initialize new cropper with 3.5:1 aspect ratio for background images
    // Banner is 350px high, and on typical desktop widths (~1200px) this gives us ~3.5:1 ratio
    // This ensures the cropped image will display properly in the banner without being cut off
    backgroundCropper = new Cropper(preview, {
      aspectRatio: 3.5, // Matches banner display ratio (approximately 1200:350)
      viewMode: 1,
      dragMode: 'move',
      autoCropArea: 0.8,
      restore: false,
      guides: true,
      center: true,
      highlight: false,
      cropBoxMovable: true,
      cropBoxResizable: true,
      toggleDragModeOnDblclick: false,
      minCropBoxWidth: 350,
      minCropBoxHeight: 100,
      zoomable: true,
      scalable: false,
      rotatable: true,
      ready: function() {
        // Reset slider tracking
        lastBackgroundSliderValue = 1;
        isUserDraggingBackgroundSlider = false;
        isUsingBackgroundZoomButtons = false;
        
        // Add event listeners to track slider dragging
        const zoomSlider = document.getElementById('background-crop-zoom-slider');
        if (zoomSlider) {
          // Track when user starts dragging
          zoomSlider.addEventListener('mousedown', function() {
            isUserDraggingBackgroundSlider = true;
          });
          zoomSlider.addEventListener('touchstart', function() {
            isUserDraggingBackgroundSlider = true;
          });
          
          // Track when user stops dragging
          zoomSlider.addEventListener('mouseup', function() {
            setTimeout(() => {
              isUserDraggingBackgroundSlider = false;
            }, 100);
          });
          zoomSlider.addEventListener('touchend', function() {
            setTimeout(() => {
              isUserDraggingBackgroundSlider = false;
            }, 100);
          });
        }
        
        // Update zoom slider when cropper is ready
        updateBackgroundZoomSlider();
        updateBackgroundZoomSliderProgress();
        updateBackgroundZoomButtonsState();
        // Show drag hint initially
        showBackgroundDragHint();
      },
      crop: function() {
        // Hide drag hint when user starts interacting
        hideBackgroundDragHint();
        // Update zoom slider progress on crop
        updateBackgroundZoomSliderProgress();
      },
      zoom: function() {
        // Only update slider if user is not actively dragging or using buttons
        if (!isUserDraggingBackgroundSlider && !isUsingBackgroundZoomButtons) {
          updateBackgroundZoomSlider();
          updateBackgroundZoomSliderProgress();
        }
      }
    });
    
    // Update zoom slider value
    updateBackgroundZoomSlider();
  };
  
  // Check if image is already loaded
  if (preview.complete) {
    // Image already loaded, initialize immediately
    setTimeout(initializeBackgroundCropper, 100);
  } else {
    // Wait for image to load
    preview.onload = initializeBackgroundCropper;
  }
}

function closeBackgroundCropModal() {
  const modal = document.getElementById('background-crop-modal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    
    // Clean up cropper
    if (backgroundCropper) {
      backgroundCropper.destroy();
      backgroundCropper = null;
    }
    
    // Clean up object URL
    const preview = document.getElementById('background-crop-preview');
    if (preview && preview.src) {
      URL.revokeObjectURL(preview.src);
      preview.src = '';
    }
    
    // Clear file input
    const fileInput = document.getElementById('background-upload-input');
    if (fileInput) {
      fileInput.value = '';
    }
    
    // Reset slider tracking
    lastBackgroundSliderValue = 1;
    selectedBackgroundFile = null;
  }
}

function saveCroppedBackgroundImage() {
  if (!backgroundCropper || !selectedBackgroundFile) {
    closeBackgroundCropModal();
    return;
  }
  
  // Get cropped canvas with 3.5:1 aspect ratio (1400x400 to match banner display)
  const canvas = backgroundCropper.getCroppedCanvas({
    width: 1400,
    height: 400,
    imageSmoothingEnabled: true,
    imageSmoothingQuality: 'high',
  });
  
  if (!canvas) {
    showError('Failed to crop image. Please try again.', 'background');
    closeBackgroundCropModal();
    return;
  }
  
  // Convert canvas to blob
  canvas.toBlob(function(blob) {
    if (!blob) {
      showError('Failed to process image. Please try again.', 'background');
      closeBackgroundCropModal();
      return;
    }
    
    // Create a File object from the blob with the original filename
    const croppedFile = new File([blob], selectedBackgroundFile.name, {
      type: selectedBackgroundFile.type,
      lastModified: Date.now()
    });
    
    // Get the form
    const form = document.querySelector('.settings-form');
    if (!form) {
      showError('Form not found. Please try again.', 'background');
      closeBackgroundCropModal();
      return;
    }
    
    // Get form action URL
    const formAction = form.action || form.getAttribute('action') || '/settings';
    
    // Get CSRF token
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || 
                     document.querySelector('input[name="authenticity_token"]')?.value || 
                     form.querySelector('input[name="authenticity_token"]')?.value;
    
    if (!csrfToken) {
      showError('Security token not found. Please refresh the page and try again.', 'background');
      closeBackgroundCropModal();
      return;
    }
    
    // Create FormData from the form
    const formData = new FormData(form);
    
    // Remove existing background image if any
    formData.delete('user[background_image]');
    
    // Add the cropped file
    formData.append('user[background_image]', croppedFile);
    
    // Set remove_background_image to false
    formData.set('remove_background_image', 'false');
    
    // Ensure CSRF token is in FormData (Rails expects it as a form field)
    const authToken = form.querySelector('input[name="authenticity_token"]');
    if (authToken) {
      formData.set('authenticity_token', authToken.value);
    }
    
    // Close the cropping modal
    closeBackgroundCropModal();
    
    // Show loader
    showBackgroundLoader();
    
    // Submit form via fetch
    fetch(formAction, {
      method: 'PATCH',
      body: formData,
      headers: {
        'X-CSRF-Token': csrfToken,
        'X-Requested-With': 'XMLHttpRequest'
      },
      credentials: 'same-origin'
    })
    .then(response => {
      if (response.redirected) {
        // If redirected, follow the redirect
        window.location.href = response.url;
      } else if (response.ok) {
        // If successful, reload the page to show the new background
        window.location.reload();
      } else {
        throw new Error('Upload failed with status: ' + response.status);
      }
    })
    .catch(error => {
      console.error('Error uploading image:', error);
      hideBackgroundLoader();
      showError('Failed to upload image. Please try again.', 'background');
    });
  }, selectedBackgroundFile.type, 0.95); // Use original file type and high quality
}

// Background rotation function
function rotateBackgroundImage(degrees) {
  if (backgroundCropper) {
    backgroundCropper.rotate(degrees);
  }
}

// Background zoom functions
function zoomBackgroundImage(ratio) {
  if (backgroundCropper) {
    const zoomSlider = document.getElementById('background-crop-zoom-slider');
    if (zoomSlider) {
      const currentValue = parseFloat(zoomSlider.value) ?? 1;
      
      // Check limits before zooming
      if (ratio > 0 && currentValue >= 2) {
        return;
      }
      if (ratio < 0 && currentValue <= 0) {
        return;
      }
      
      isUsingBackgroundZoomButtons = true;
      
      // Adjust slider value based on zoom ratio
      const newValue = Math.max(0, Math.min(2, currentValue + (ratio * 2)));
      
      // Update slider value BEFORE zooming to prevent reset
      zoomSlider.value = newValue;
      lastBackgroundSliderValue = newValue;
      updateBackgroundZoomSliderProgress();
      updateBackgroundZoomButtonsState();
    }
    
    // Apply zoom
    backgroundCropper.zoom(ratio);
    
    // Reset flag after a short delay
    setTimeout(() => {
      isUsingBackgroundZoomButtons = false;
    }, 150);
  }
}

function updateBackgroundZoom(value) {
  if (backgroundCropper) {
    isUserDraggingBackgroundSlider = true;
    const sliderValue = parseFloat(value);
    
    // Calculate the difference from the last slider value
    const sliderDiff = sliderValue - lastBackgroundSliderValue;
    
    // Map slider difference to zoom ratio
    const zoomRatio = sliderDiff * 0.5;
    
    // Apply zoom if there's a meaningful change
    if (Math.abs(zoomRatio) > 0.01) {
      backgroundCropper.zoom(zoomRatio);
      lastBackgroundSliderValue = sliderValue;
    }
    
    // Always update progress bar and button states
    updateBackgroundZoomSliderProgress();
    updateBackgroundZoomButtonsState();
    
    // Reset flag after a short delay
    setTimeout(() => {
      isUserDraggingBackgroundSlider = false;
    }, 100);
  }
}

function updateBackgroundZoomSliderProgress() {
  const zoomSlider = document.getElementById('background-crop-zoom-slider');
  if (zoomSlider) {
    const sliderValue = parseFloat(zoomSlider.value) ?? 1;
    const progress = Math.max(0, Math.min(100, (sliderValue / 2) * 100));
    zoomSlider.style.setProperty('--slider-progress', progress + '%');
    
    // Also update button states
    updateBackgroundZoomButtonsState();
  }
}

function updateBackgroundZoomSlider() {
  if (backgroundCropper && !isUserDraggingBackgroundSlider && !isUsingBackgroundZoomButtons) {
    const zoomSlider = document.getElementById('background-crop-zoom-slider');
    if (zoomSlider) {
      lastBackgroundSliderValue = parseFloat(zoomSlider.value) ?? 1;
      updateBackgroundZoomSliderProgress();
    }
  }
}

// Update background zoom buttons state
function updateBackgroundZoomButtonsState() {
  const zoomSlider = document.getElementById('background-crop-zoom-slider');
  const minusBtn = document.getElementById('background-crop-zoom-minus-btn');
  const plusBtn = document.getElementById('background-crop-zoom-plus-btn');
  
  if (zoomSlider && minusBtn && plusBtn) {
    const sliderValue = parseFloat(zoomSlider.value) ?? 1;
    
    // Disable minus button if at minimum (0)
    if (sliderValue <= 0) {
      minusBtn.disabled = true;
      minusBtn.style.opacity = '0.5';
      minusBtn.style.cursor = 'not-allowed';
    } else {
      minusBtn.disabled = false;
      minusBtn.style.opacity = '1';
      minusBtn.style.cursor = 'pointer';
    }
    
    // Disable plus button if at maximum (2)
    if (sliderValue >= 2) {
      plusBtn.disabled = true;
      plusBtn.style.opacity = '0.5';
      plusBtn.style.cursor = 'not-allowed';
    } else {
      plusBtn.disabled = false;
      plusBtn.style.opacity = '1';
      plusBtn.style.cursor = 'pointer';
    }
  }
}

// Show/hide background drag hint
function showBackgroundDragHint() {
  const dragHint = document.querySelector('.background-crop-drag-hint');
  if (dragHint) {
    dragHint.style.opacity = '1';
    dragHint.style.visibility = 'visible';
  }
}

function hideBackgroundDragHint() {
  const dragHint = document.querySelector('.background-crop-drag-hint');
  if (dragHint) {
    dragHint.style.opacity = '0';
    dragHint.style.visibility = 'hidden';
  }
}

// Close background crop modal when clicking overlay
document.addEventListener('click', function(e) {
  if (e.target.classList.contains('background-crop-overlay')) {
    closeBackgroundCropModal();
  }
});

document.addEventListener('DOMContentLoaded', function() {
  hideAvatarLoader();
  hideBackgroundLoader();
});
</script> 