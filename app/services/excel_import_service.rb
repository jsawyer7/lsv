class ExcelImportService
  require 'roo'

  def initialize
    @file_mappings = {
      'families_for_foundations.xlsx' => {
        model: FamiliesForFoundation,
        columns: ['code', 'name', 'domain', 'description', 'display_order', 'is_active']
      },
      'foundations_only.xlsx' => {
        model: FoundationsOnly,
        columns: ['code', 'title', 'tradition_code', 'lang_code', 'scope', 'pub_range', 'citation_hint', 'is_active']
      },
      'languages.xlsx' => {
        model: Language,
        columns: ['code', 'name', 'iso_639_3', 'script', 'direction', 'language_family', 'notes']
      },
      'master_books.xlsx' => {
        model: MasterBook,
        columns: ['code', 'title', 'family_code', 'origin_lang', 'notes']
      },
      'families_seed.xlsx' => {
        model: FamiliesSeed,
        columns: ['id', 'code', 'name', 'notes']
      },
      # Phase 1 tables
      'canons.xlsx' => {
        model: Canon,
        columns: ['code', 'name', 'domain_code', 'description', 'is_official', 'display_order']
      },
      'canon_book_inclusions.xlsx' => {
        model: CanonBookInclusion,
        columns: ['canon_id', 'work_code', 'include_from', 'include_to', 'notes']
      },
      'canon_work_preferences.xlsx' => {
        model: CanonWorkPreference,
        columns: ['canon_id', 'work_code', 'foundation_code', 'numbering_system_code', 'notes']
      },
      # Phase 2 tables - Numbering System Management
      'numbering_system.xlsx' => {
        model: NumberingSystem,
        columns: ['code', 'name', 'description']
      },
      'numbering_label.xlsx' => {
        model: NumberingLabel,
        columns: ['numbering_system_id', 'system_code', 'label', 'locale', 'applies_to', 'description']
      },
      'numbering_map.xlsx' => {
        model: NumberingMap,
        columns: ['numbering_system_id', 'unit_id', 'work_code', 'l1', 'l2', 'l3', 'n_book', 'n_chapter', 'n_verse', 'n_sub', 'status']
      }
    }
  end

  def import_all_files
    results = {}
    
    @file_mappings.each do |filename, config|
      puts "Importing #{filename}..."
      results[filename] = import_file(filename, config)
    end
    
    results
  end

  def import_file(filename, config)
    file_path = Rails.root.join('data', filename)
    
    unless File.exist?(file_path)
      return { success: false, error: "File not found: #{filename}" }
    end

    begin
      workbook = Roo::Excelx.new(file_path)
      sheet = workbook.sheet(0)
      
      # Get headers from first row
      headers = sheet.row(1)
      
      # Validate headers match expected columns
      unless headers == config[:columns]
        return { 
          success: false, 
          error: "Headers mismatch. Expected: #{config[:columns]}, Got: #{headers}" 
        }
      end
      
      model_class = config[:model]
      imported_count = 0
      error_count = 0
      errors = []
      
      # Start from row 2 (skip header)
      (2..sheet.last_row).each do |row_num|
        row_data = sheet.row(row_num)
        
        # Create hash from headers and row data
        record_data = {}
        headers.each_with_index do |header, index|
          value = row_data[index]
          
          # Skip id column as it's auto-generated by Rails
          next if header == 'id'
          
          # Handle boolean conversion for is_active field
          if header == 'is_active' && !value.nil?
            value = value.to_s.downcase == 'true'
          end
          
          # Handle integer conversion for display_order
          if header == 'display_order' && !value.nil?
            value = value.to_i
          end
          
          record_data[header] = value
        end
        
        begin
          # Handle different primary key strategies
          if model_class == CanonBookInclusion || model_class == CanonWorkPreference
            # Composite primary key tables
            existing_record = model_class.find_by(
              canon_id: record_data['canon_id'],
              work_code: record_data['work_code']
            )
            
            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: Canon #{record_data['canon_id']}, Work #{record_data['work_code']}"
            else
              # Create new record
              model_class.create!(record_data)
              puts "  Created: Canon #{record_data['canon_id']}, Work #{record_data['work_code']}"
            end
          elsif model_class == NumberingLabel
            # NumberingLabel has composite key (numbering_system_id, system_code)
            existing_record = model_class.find_by(
              numbering_system_id: record_data['numbering_system_id'],
              system_code: record_data['system_code']
            )
            
            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: System #{record_data['numbering_system_id']}, Code #{record_data['system_code']}"
            else
              # Create new record
              model_class.create!(record_data)
              puts "  Created: System #{record_data['numbering_system_id']}, Code #{record_data['system_code']}"
            end
          elsif model_class == NumberingMap
            # NumberingMap has composite key (numbering_system_id, unit_id)
            existing_record = model_class.find_by(
              numbering_system_id: record_data['numbering_system_id'],
              unit_id: record_data['unit_id']
            )
            
            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: System #{record_data['numbering_system_id']}, Unit #{record_data['unit_id']}"
            else
              # Create new record
              model_class.create!(record_data)
              puts "  Created: System #{record_data['numbering_system_id']}, Unit #{record_data['unit_id']}"
            end
          else
            # Standard primary key tables (code-based)
            existing_record = model_class.find_by(code: record_data['code'])
            
            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: #{record_data['code']}"
            else
              # Create new record
              model_class.create!(record_data)
              puts "  Created: #{record_data['code']}"
            end
          end
          
          imported_count += 1
        rescue => e
          error_count += 1
          error_msg = "Row #{row_num}: #{e.message}"
          errors << error_msg
          puts "  Error: #{error_msg}"
        end
      end
      
      {
        success: true,
        imported_count: imported_count,
        error_count: error_count,
        errors: errors
      }
      
    rescue => e
      { success: false, error: "File processing error: #{e.message}" }
    end
  end

  def clear_all_data
    puts "Clearing all data from tables..."
    
    @file_mappings.each do |filename, config|
      model_class = config[:model]
      count = model_class.count
      model_class.destroy_all
      puts "  Cleared #{count} records from #{model_class.name}"
    end
  end

  def dry_run(filename = nil)
    if filename
      config = @file_mappings[filename]
      return { success: false, error: "File not found in mappings: #{filename}" } unless config
      
      dry_run_file(filename, config)
    else
      results = {}
      @file_mappings.each do |filename, config|
        results[filename] = dry_run_file(filename, config)
      end
      results
    end
  end

  private

  def dry_run_file(filename, config)
    file_path = Rails.root.join('data', filename)
    
    unless File.exist?(file_path)
      return { success: false, error: "File not found: #{filename}" }
    end

    begin
      workbook = Roo::Excelx.new(file_path)
      sheet = workbook.sheet(0)
      
      headers = sheet.row(1)
      
      unless headers == config[:columns]
        return { 
          success: false, 
          error: "Headers mismatch. Expected: #{config[:columns]}, Got: #{headers}" 
        }
      end
      
      total_rows = sheet.last_row - 1 # Exclude header
      existing_count = config[:model].count
      
      {
        success: true,
        total_rows: total_rows,
        existing_records: existing_count,
        headers: headers
      }
      
    rescue => e
      { success: false, error: "File processing error: #{e.message}" }
    end
  end
end
