class ExcelImportService
  require 'roo'

  def initialize
    @file_mappings = {
      'families_for_foundations.xlsx' => {
        model: FamiliesForFoundation,
        columns: ['code', 'name', 'domain', 'description', 'display_order', 'is_active']
      },
      'foundations_only.xlsx' => {
        model: FoundationsOnly,
        columns: ['code', 'title', 'tradition_code', 'lang_code', 'scope', 'pub_range', 'citation_hint', 'is_active']
      },
      'languages.xlsx' => {
        model: Language,
        columns: ['code', 'name', 'iso_639_3', 'script', 'direction', 'language_family', 'notes']
      },
      'master_books.xlsx' => {
        model: MasterBook,
        columns: ['code', 'title', 'family_code', 'origin_lang', 'notes']
      },
      'families_seed.xlsx' => {
        model: FamiliesSeed,
        columns: ['id', 'code', 'name', 'notes']
      },
      # Phase 1 tables
      'canons.xlsx' => {
        model: Canon,
        columns: ['code', 'name', 'domain_code', 'description', 'is_official', 'display_order']
      },
      'canon_book_inclusions.xlsx' => {
        model: CanonBookInclusion,
        columns: ['canon_id', 'work_code', 'include_from', 'include_to', 'notes']
      },
      'canon_work_preferences.xlsx' => {
        model: CanonWorkPreference,
        columns: ['canon_id', 'work_code', 'foundation_code', 'numbering_system_code', 'notes']
      },
      # Phase 2 tables - Numbering System Management (order matters for dependencies)
      'numbering_system.xlsx' => {
        model: NumberingSystem,
        columns: ['code', 'name', 'description']
      },
      'numbering_label.xlsx' => {
        model: NumberingLabel,
        columns: ['numbering_system_id', 'system_code', 'label', 'locale', 'applies_to', 'description']
      },
      'numbering_map.xlsx' => {
        model: NumberingMap,
        columns: ['numbering_system_id', 'unit_id', 'work_code', 'l1', 'l2', 'l3', 'n_book', 'n_chapter', 'n_verse', 'n_sub', 'status']
      }
    }
  end

  def import_all_files
    results = {}

    @file_mappings.each do |filename, config|
      puts "Importing #{filename}..."
      results[filename] = import_file(filename, config)
    end

    results
  end

  def import_file(filename, config)
    file_path = Rails.root.join('data', filename)

    unless File.exist?(file_path)
      return { success: false, error: "File not found: #{filename}" }
    end

    begin
      workbook = Roo::Excelx.new(file_path)
      sheet = workbook.sheet(0)

      # Get headers from first row
      headers = sheet.row(1)

      # Validate headers match expected columns
      unless headers == config[:columns]
        return {
          success: false,
          error: "Headers mismatch. Expected: #{config[:columns]}, Got: #{headers}"
        }
      end

      model_class = config[:model]
      imported_count = 0
      error_count = 0
      errors = []

      # Start from row 2 (skip header)
      (2..sheet.last_row).each do |row_num|
        row_data = sheet.row(row_num)

        # Create hash from headers and row data
        record_data = {}
        headers.each_with_index do |header, index|
          value = row_data[index]

          # Skip id column as it's auto-generated by Rails
          next if header == 'id'

          # Handle boolean conversion for is_active field
          if header == 'is_active' && !value.nil?
            value = value.to_s.downcase == 'true'
          end

          # Handle foreign key mappings
          if header == 'canon_id' && !value.nil?
            # Map Excel canon IDs (1-7) to actual database IDs dynamically
            canon_codes = ['HEB_MT', 'HEB_LXX', 'NT_GR', 'NT_LAT', 'QUR_U', 'PAL_PTS', 'SKT_BORI']
            excel_id = value.to_i
            if excel_id >= 1 && excel_id <= canon_codes.length
              canon_code = canon_codes[excel_id - 1]
              canon = Canon.find_by(code: canon_code)
              value = canon.id if canon
            end
          end

          if header == 'numbering_system_id' && !value.nil?
            # Map numbering system codes to IDs
            numbering_system = NumberingSystem.find_by(code: value.to_s)
            if numbering_system
              value = numbering_system.id
            else
              # Set to nil and let validation handle it gracefully
              puts "  Warning: NumberingSystem with code '#{value}' not found, setting to nil"
              value = nil
            end
          end

          # Handle integer conversion for display_order
          if header == 'display_order' && !value.nil?
            value = value.to_i
          end

          record_data[header] = value
        end

        begin
          # Handle different primary key strategies
          if model_class == CanonBookInclusion || model_class == CanonWorkPreference
            # Composite primary key tables
            existing_record = model_class.find_by(
              canon_id: record_data['canon_id'],
              work_code: record_data['work_code']
            )

            if existing_record
              # Update existing record using raw SQL to avoid composite primary key issues
              set_clause = record_data.map { |k, v| "#{k} = '#{v}'" }.join(', ')
              sql = "UPDATE #{model_class.table_name} SET #{set_clause} WHERE canon_id = #{record_data['canon_id']} AND work_code = '#{record_data['work_code']}'"
              ActiveRecord::Base.connection.execute(sql)
              puts "  Updated: Canon #{record_data['canon_id']}, Work #{record_data['work_code']}"
            else
              # Create new record using raw SQL to avoid composite primary key issues
              current_time = Time.current.to_s(:db)
              columns = (record_data.keys + ['created_at', 'updated_at']).join(', ')
              values = (record_data.values + [current_time, current_time]).map { |v| "'#{v}'" }.join(', ')
              sql = "INSERT INTO #{model_class.table_name} (#{columns}) VALUES (#{values})"
              ActiveRecord::Base.connection.execute(sql)
              puts "  Created: Canon #{record_data['canon_id']}, Work #{record_data['work_code']}"
            end
          elsif model_class == NumberingLabel
            # NumberingLabel has composite key (numbering_system_id, system_code)
            # Skip if numbering_system_id is nil (missing dependency)
            if record_data['numbering_system_id'].nil?
              puts "  Skipped: System ID is nil for code #{record_data['system_code']} (missing NumberingSystem dependency)"
              next
            end

            existing_record = model_class.find_by(
              numbering_system_id: record_data['numbering_system_id'],
              system_code: record_data['system_code']
            )

            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: System #{record_data['numbering_system_id']}, Code #{record_data['system_code']}"
            else
              # Create new record using insert to avoid composite primary key issues
              record = model_class.new(record_data)
              if record.save
                puts "  Created: System #{record_data['numbering_system_id']}, Code #{record_data['system_code']}"
              else
                puts "  Error: #{record.errors.full_messages.join(', ')}"
              end
            end
          elsif model_class == NumberingMap
            # NumberingMap has composite key (numbering_system_id, unit_id)
            existing_record = model_class.find_by(
              numbering_system_id: record_data['numbering_system_id'],
              unit_id: record_data['unit_id']
            )

            if existing_record
              # Update existing record using raw SQL to avoid composite primary key issues
              set_clause = record_data.map { |k, v| "#{k} = '#{v}'" }.join(', ')
              sql = "UPDATE #{model_class.table_name} SET #{set_clause} WHERE numbering_system_id = #{record_data['numbering_system_id']} AND unit_id = '#{record_data['unit_id']}'"
              ActiveRecord::Base.connection.execute(sql)
              puts "  Updated: System #{record_data['numbering_system_id']}, Unit #{record_data['unit_id']}"
            else
              # Create new record using raw SQL to avoid composite primary key issues
              current_time = Time.current.to_s(:db)
              columns = (record_data.keys + ['created_at', 'updated_at']).join(', ')
              values = (record_data.values + [current_time, current_time]).map { |v| "'#{v}'" }.join(', ')
              sql = "INSERT INTO #{model_class.table_name} (#{columns}) VALUES (#{values})"
              ActiveRecord::Base.connection.execute(sql)
              puts "  Created: System #{record_data['numbering_system_id']}, Unit #{record_data['unit_id']}"
            end
          else
            # Standard primary key tables (code-based)
            existing_record = model_class.find_by(code: record_data['code'])

            if existing_record
              # Update existing record
              existing_record.update!(record_data)
              puts "  Updated: #{record_data['code']}"
            else
              # Create new record
              model_class.create!(record_data)
              puts "  Created: #{record_data['code']}"
            end
          end

          imported_count += 1
        rescue => e
          error_count += 1
          error_msg = "Row #{row_num}: #{e.message}"
          errors << error_msg
          puts "  Error: #{error_msg}"
        end
      end

      {
        success: true,
        imported_count: imported_count,
        error_count: error_count,
        errors: errors
      }

    rescue => e
      { success: false, error: "File processing error: #{e.message}" }
    end
  end

  def clear_all_data
    puts "Clearing all data from tables..."

    @file_mappings.each do |filename, config|
      model_class = config[:model]
      count = model_class.count

      # Special handling for NumberingSystem - preserve manually added systems
      if model_class == NumberingSystem
        # Only clear systems that are in the Excel file, preserve manually added ones
        excel_systems = ['MT_OT', 'NA28_NT', 'LXX_Psalms_151', 'LXX_DC', 'GEE_EXTRAS', 'LDS_STD', 'QUR_STD', 'PAL_STD', 'CHI_T_STD', 'TIB_DER_STD', 'SKT_GITA', 'SKT_MBH', 'SKT_RMY', 'SKT_UP', 'SKT_PUR', 'SKT_SMR', 'SKT_STD']
        model_class.where(code: excel_systems).destroy_all
        puts "  Cleared Excel numbering systems from #{model_class.name} (preserved manually added ones)"
      elsif model_class.primary_key.is_a?(Array)
        # For composite primary keys, use raw SQL to avoid Rails ORM issues
        table_name = model_class.table_name
        ActiveRecord::Base.connection.execute("DELETE FROM #{table_name}")
        puts "  Cleared #{count} records from #{model_class.name}"
      else
        model_class.destroy_all
        puts "  Cleared #{count} records from #{model_class.name}"
      end
    end
  end

  def dry_run(filename = nil)
    if filename
      config = @file_mappings[filename]
      return { success: false, error: "File not found in mappings: #{filename}" } unless config

      dry_run_file(filename, config)
    else
      results = {}
      @file_mappings.each do |filename, config|
        results[filename] = dry_run_file(filename, config)
      end
      results
    end
  end

  private

  def dry_run_file(filename, config)
    file_path = Rails.root.join('data', filename)

    unless File.exist?(file_path)
      return { success: false, error: "File not found: #{filename}" }
    end

    begin
      workbook = Roo::Excelx.new(file_path)
      sheet = workbook.sheet(0)

      headers = sheet.row(1)

      unless headers == config[:columns]
        return {
          success: false,
          error: "Headers mismatch. Expected: #{config[:columns]}, Got: #{headers}"
        }
      end

      total_rows = sheet.last_row - 1 # Exclude header
      existing_count = config[:model].count

      {
        success: true,
        total_rows: total_rows,
        existing_records: existing_count,
        headers: headers
      }

    rescue => e
      { success: false, error: "File processing error: #{e.message}" }
    end
  end
end
